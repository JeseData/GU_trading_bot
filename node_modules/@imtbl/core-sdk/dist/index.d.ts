import { Event, EventFilter, utils, BigNumberish, BytesLike, BaseContract, Signer, CallOverrides, BigNumber, Overrides, ContractTransaction, PopulatedTransaction, PayableOverrides, ContractFactory } from 'ethers';
import { Listener, Provider, TransactionRequest } from '@ethersproject/providers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import { Signer as Signer$1 } from '@ethersproject/abstract-signer';
export { Signer as EthSigner } from '@ethersproject/abstract-signer';
import * as axios from 'axios';
import { AxiosRequestConfig, AxiosInstance, AxiosPromise } from 'axios';
import * as _ethersproject_abstract_provider from '@ethersproject/abstract-provider';

interface TypedEvent<TArgsArray extends Array<any> = any, TArgsObject = any> extends Event {
    args: TArgsArray & TArgsObject;
}
interface TypedEventFilter<_TEvent extends TypedEvent> extends EventFilter {
}
interface TypedListener<TEvent extends TypedEvent> {
    (...listenerArg: [...__TypechainArgsArray<TEvent>, TEvent]): void;
}
declare type __TypechainArgsArray<T> = T extends TypedEvent<infer U> ? U : never;
interface OnEvent<TRes> {
    <TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>, listener: TypedListener<TEvent>): TRes;
    (eventName: string, listener: Listener): TRes;
}

interface IERC20Interface extends utils.Interface {
    functions: {
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "allowance" | "approve" | "balanceOf" | "totalSupply" | "transfer" | "transferFrom"): FunctionFragment;
    encodeFunctionData(functionFragment: "allowance", values: [string, string]): string;
    encodeFunctionData(functionFragment: "approve", values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [string]): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [string, string, BigNumberish]): string;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$1 {
    owner: string;
    spender: string;
    value: BigNumber;
}
declare type ApprovalEvent$1 = TypedEvent<[
    string,
    string,
    BigNumber
], ApprovalEventObject$1>;
declare type ApprovalEventFilter$1 = TypedEventFilter<ApprovalEvent$1>;
interface TransferEventObject$1 {
    from: string;
    to: string;
    value: BigNumber;
}
declare type TransferEvent$1 = TypedEvent<[
    string,
    string,
    BigNumber
], TransferEventObject$1>;
declare type TransferEventFilter$1 = TypedEventFilter<TransferEvent$1>;
interface IERC20 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IERC20Interface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        approve(spender: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;
        transfer(to: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        transferFrom(from: string, to: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<BigNumber>;
    approve(spender: string, amount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;
    transfer(to: string, amount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    transferFrom(from: string, to: string, amount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<BigNumber>;
        approve(spender: string, amount: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;
        transfer(to: string, amount: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(from: string, to: string, amount: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: string | null, spender?: string | null, value?: null): ApprovalEventFilter$1;
        Approval(owner?: string | null, spender?: string | null, value?: null): ApprovalEventFilter$1;
        "Transfer(address,address,uint256)"(from?: string | null, to?: string | null, value?: null): TransferEventFilter$1;
        Transfer(from?: string | null, to?: string | null, value?: null): TransferEventFilter$1;
    };
    estimateGas: {
        allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<BigNumber>;
        approve(spender: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;
        transfer(to: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        transferFrom(from: string, to: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(to: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(from: string, to: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface IERC721Interface extends utils.Interface {
    functions: {
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "getApproved(uint256)": FunctionFragment;
        "isApprovedForAll(address,address)": FunctionFragment;
        "ownerOf(uint256)": FunctionFragment;
        "safeTransferFrom(address,address,uint256)": FunctionFragment;
        "safeTransferFrom(address,address,uint256,bytes)": FunctionFragment;
        "setApprovalForAll(address,bool)": FunctionFragment;
        "supportsInterface(bytes4)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "approve" | "balanceOf" | "getApproved" | "isApprovedForAll" | "ownerOf" | "safeTransferFrom(address,address,uint256)" | "safeTransferFrom(address,address,uint256,bytes)" | "setApprovalForAll" | "supportsInterface" | "transferFrom"): FunctionFragment;
    encodeFunctionData(functionFragment: "approve", values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [string]): string;
    encodeFunctionData(functionFragment: "getApproved", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "isApprovedForAll", values: [string, string]): string;
    encodeFunctionData(functionFragment: "ownerOf", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "safeTransferFrom(address,address,uint256)", values: [string, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "safeTransferFrom(address,address,uint256,bytes)", values: [string, string, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "setApprovalForAll", values: [string, boolean]): string;
    encodeFunctionData(functionFragment: "supportsInterface", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [string, string, BigNumberish]): string;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getApproved", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isApprovedForAll", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "ownerOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "safeTransferFrom(address,address,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "safeTransferFrom(address,address,uint256,bytes)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setApprovalForAll", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "supportsInterface", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "ApprovalForAll(address,address,bool)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ApprovalForAll"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject {
    owner: string;
    approved: string;
    tokenId: BigNumber;
}
declare type ApprovalEvent = TypedEvent<[
    string,
    string,
    BigNumber
], ApprovalEventObject>;
declare type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;
interface ApprovalForAllEventObject {
    owner: string;
    operator: string;
    approved: boolean;
}
declare type ApprovalForAllEvent = TypedEvent<[
    string,
    string,
    boolean
], ApprovalForAllEventObject>;
declare type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;
interface TransferEventObject {
    from: string;
    to: string;
    tokenId: BigNumber;
}
declare type TransferEvent = TypedEvent<[
    string,
    string,
    BigNumber
], TransferEventObject>;
declare type TransferEventFilter = TypedEventFilter<TransferEvent>;
interface IERC721 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IERC721Interface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        approve(to: string, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        balanceOf(owner: string, overrides?: CallOverrides): Promise<[BigNumber] & {
            balance: BigNumber;
        }>;
        getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string] & {
            operator: string;
        }>;
        isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<[boolean]>;
        ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string] & {
            owner: string;
        }>;
        "safeTransferFrom(address,address,uint256)"(from: string, to: string, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        "safeTransferFrom(address,address,uint256,bytes)"(from: string, to: string, tokenId: BigNumberish, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setApprovalForAll(operator: string, _approved: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;
        transferFrom(from: string, to: string, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    approve(to: string, tokenId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
    getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;
    isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<boolean>;
    ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;
    "safeTransferFrom(address,address,uint256)"(from: string, to: string, tokenId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    "safeTransferFrom(address,address,uint256,bytes)"(from: string, to: string, tokenId: BigNumberish, data: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setApprovalForAll(operator: string, _approved: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;
    transferFrom(from: string, to: string, tokenId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        approve(to: string, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
        getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;
        isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<boolean>;
        ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;
        "safeTransferFrom(address,address,uint256)"(from: string, to: string, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        "safeTransferFrom(address,address,uint256,bytes)"(from: string, to: string, tokenId: BigNumberish, data: BytesLike, overrides?: CallOverrides): Promise<void>;
        setApprovalForAll(operator: string, _approved: boolean, overrides?: CallOverrides): Promise<void>;
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(from: string, to: string, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: string | null, approved?: string | null, tokenId?: BigNumberish | null): ApprovalEventFilter;
        Approval(owner?: string | null, approved?: string | null, tokenId?: BigNumberish | null): ApprovalEventFilter;
        "ApprovalForAll(address,address,bool)"(owner?: string | null, operator?: string | null, approved?: null): ApprovalForAllEventFilter;
        ApprovalForAll(owner?: string | null, operator?: string | null, approved?: null): ApprovalForAllEventFilter;
        "Transfer(address,address,uint256)"(from?: string | null, to?: string | null, tokenId?: BigNumberish | null): TransferEventFilter;
        Transfer(from?: string | null, to?: string | null, tokenId?: BigNumberish | null): TransferEventFilter;
    };
    estimateGas: {
        approve(to: string, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
        getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<BigNumber>;
        ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        "safeTransferFrom(address,address,uint256)"(from: string, to: string, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        "safeTransferFrom(address,address,uint256,bytes)"(from: string, to: string, tokenId: BigNumberish, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setApprovalForAll(operator: string, _approved: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        transferFrom(from: string, to: string, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        approve(to: string, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(owner: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        "safeTransferFrom(address,address,uint256)"(from: string, to: string, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        "safeTransferFrom(address,address,uint256,bytes)"(from: string, to: string, tokenId: BigNumberish, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setApprovalForAll(operator: string, _approved: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transferFrom(from: string, to: string, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface CoreInterface extends utils.Interface {
    functions: {
        "announceAvailabilityVerifierRemovalIntent(address)": FunctionFragment;
        "announceVerifierRemovalIntent(address)": FunctionFragment;
        "deposit(uint256,uint256,uint256)": FunctionFragment;
        "deposit(uint256,uint256,uint256,uint256)": FunctionFragment;
        "depositCancel(uint256,uint256,uint256)": FunctionFragment;
        "depositERC20(uint256,uint256,uint256,uint256)": FunctionFragment;
        "depositEth(uint256,uint256,uint256)": FunctionFragment;
        "depositNft(uint256,uint256,uint256,uint256)": FunctionFragment;
        "depositNftReclaim(uint256,uint256,uint256,uint256)": FunctionFragment;
        "depositReclaim(uint256,uint256,uint256)": FunctionFragment;
        "escape(uint256,uint256,uint256,uint256)": FunctionFragment;
        "freezeRequest(uint256,uint256)": FunctionFragment;
        "fullWithdrawalRequest(uint256,uint256)": FunctionFragment;
        "getAssetInfo(uint256)": FunctionFragment;
        "getCancellationRequest(uint256,uint256,uint256)": FunctionFragment;
        "getDepositBalance(uint256,uint256,uint256)": FunctionFragment;
        "getEthKey(uint256)": FunctionFragment;
        "getFullWithdrawalRequest(uint256,uint256)": FunctionFragment;
        "getLastBatchId()": FunctionFragment;
        "getOrderRoot()": FunctionFragment;
        "getOrderTreeHeight()": FunctionFragment;
        "getQuantizedDepositBalance(uint256,uint256,uint256)": FunctionFragment;
        "getQuantum(uint256)": FunctionFragment;
        "getRegisteredAvailabilityVerifiers()": FunctionFragment;
        "getRegisteredVerifiers()": FunctionFragment;
        "getSequenceNumber()": FunctionFragment;
        "getVaultRoot()": FunctionFragment;
        "getVaultTreeHeight()": FunctionFragment;
        "getWithdrawalBalance(uint256,uint256)": FunctionFragment;
        "isAvailabilityVerifier(address)": FunctionFragment;
        "isFrozen()": FunctionFragment;
        "isOperator(address)": FunctionFragment;
        "isTokenAdmin(address)": FunctionFragment;
        "isUserAdmin(address)": FunctionFragment;
        "isVerifier(address)": FunctionFragment;
        "mainAcceptGovernance()": FunctionFragment;
        "mainCancelNomination()": FunctionFragment;
        "mainIsGovernor(address)": FunctionFragment;
        "mainNominateNewGovernor(address)": FunctionFragment;
        "mainRemoveGovernor(address)": FunctionFragment;
        "onERC721Received(address,address,uint256,bytes)": FunctionFragment;
        "registerAndDepositERC20(address,uint256,bytes,uint256,uint256,uint256)": FunctionFragment;
        "registerAndDepositEth(address,uint256,bytes,uint256,uint256)": FunctionFragment;
        "registerAvailabilityVerifier(address,string)": FunctionFragment;
        "registerOperator(address)": FunctionFragment;
        "registerToken(uint256,bytes)": FunctionFragment;
        "registerTokenAdmin(address)": FunctionFragment;
        "registerUser(address,uint256,bytes)": FunctionFragment;
        "registerUserAdmin(address)": FunctionFragment;
        "registerVerifier(address,string)": FunctionFragment;
        "removeAvailabilityVerifier(address)": FunctionFragment;
        "removeVerifier(address)": FunctionFragment;
        "unFreeze()": FunctionFragment;
        "unregisterOperator(address)": FunctionFragment;
        "unregisterTokenAdmin(address)": FunctionFragment;
        "unregisterUserAdmin(address)": FunctionFragment;
        "updateState(uint256[],uint256[])": FunctionFragment;
        "withdraw(uint256,uint256)": FunctionFragment;
        "withdrawAndMint(uint256,uint256,bytes)": FunctionFragment;
        "withdrawNft(uint256,uint256,uint256)": FunctionFragment;
        "withdrawNftTo(uint256,uint256,uint256,address)": FunctionFragment;
        "withdrawTo(uint256,uint256,address)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "announceAvailabilityVerifierRemovalIntent" | "announceVerifierRemovalIntent" | "deposit(uint256,uint256,uint256)" | "deposit(uint256,uint256,uint256,uint256)" | "depositCancel" | "depositERC20" | "depositEth" | "depositNft" | "depositNftReclaim" | "depositReclaim" | "escape" | "freezeRequest" | "fullWithdrawalRequest" | "getAssetInfo" | "getCancellationRequest" | "getDepositBalance" | "getEthKey" | "getFullWithdrawalRequest" | "getLastBatchId" | "getOrderRoot" | "getOrderTreeHeight" | "getQuantizedDepositBalance" | "getQuantum" | "getRegisteredAvailabilityVerifiers" | "getRegisteredVerifiers" | "getSequenceNumber" | "getVaultRoot" | "getVaultTreeHeight" | "getWithdrawalBalance" | "isAvailabilityVerifier" | "isFrozen" | "isOperator" | "isTokenAdmin" | "isUserAdmin" | "isVerifier" | "mainAcceptGovernance" | "mainCancelNomination" | "mainIsGovernor" | "mainNominateNewGovernor" | "mainRemoveGovernor" | "onERC721Received" | "registerAndDepositERC20" | "registerAndDepositEth" | "registerAvailabilityVerifier" | "registerOperator" | "registerToken" | "registerTokenAdmin" | "registerUser" | "registerUserAdmin" | "registerVerifier" | "removeAvailabilityVerifier" | "removeVerifier" | "unFreeze" | "unregisterOperator" | "unregisterTokenAdmin" | "unregisterUserAdmin" | "updateState" | "withdraw" | "withdrawAndMint" | "withdrawNft" | "withdrawNftTo" | "withdrawTo"): FunctionFragment;
    encodeFunctionData(functionFragment: "announceAvailabilityVerifierRemovalIntent", values: [string]): string;
    encodeFunctionData(functionFragment: "announceVerifierRemovalIntent", values: [string]): string;
    encodeFunctionData(functionFragment: "deposit(uint256,uint256,uint256)", values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "deposit(uint256,uint256,uint256,uint256)", values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "depositCancel", values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "depositERC20", values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "depositEth", values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "depositNft", values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "depositNftReclaim", values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "depositReclaim", values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "escape", values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "freezeRequest", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "fullWithdrawalRequest", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getAssetInfo", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "getCancellationRequest", values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getDepositBalance", values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getEthKey", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "getFullWithdrawalRequest", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getLastBatchId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getOrderRoot", values?: undefined): string;
    encodeFunctionData(functionFragment: "getOrderTreeHeight", values?: undefined): string;
    encodeFunctionData(functionFragment: "getQuantizedDepositBalance", values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getQuantum", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "getRegisteredAvailabilityVerifiers", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRegisteredVerifiers", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSequenceNumber", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVaultRoot", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVaultTreeHeight", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWithdrawalBalance", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "isAvailabilityVerifier", values: [string]): string;
    encodeFunctionData(functionFragment: "isFrozen", values?: undefined): string;
    encodeFunctionData(functionFragment: "isOperator", values: [string]): string;
    encodeFunctionData(functionFragment: "isTokenAdmin", values: [string]): string;
    encodeFunctionData(functionFragment: "isUserAdmin", values: [string]): string;
    encodeFunctionData(functionFragment: "isVerifier", values: [string]): string;
    encodeFunctionData(functionFragment: "mainAcceptGovernance", values?: undefined): string;
    encodeFunctionData(functionFragment: "mainCancelNomination", values?: undefined): string;
    encodeFunctionData(functionFragment: "mainIsGovernor", values: [string]): string;
    encodeFunctionData(functionFragment: "mainNominateNewGovernor", values: [string]): string;
    encodeFunctionData(functionFragment: "mainRemoveGovernor", values: [string]): string;
    encodeFunctionData(functionFragment: "onERC721Received", values: [string, string, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "registerAndDepositERC20", values: [
        string,
        BigNumberish,
        BytesLike,
        BigNumberish,
        BigNumberish,
        BigNumberish
    ]): string;
    encodeFunctionData(functionFragment: "registerAndDepositEth", values: [string, BigNumberish, BytesLike, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "registerAvailabilityVerifier", values: [string, string]): string;
    encodeFunctionData(functionFragment: "registerOperator", values: [string]): string;
    encodeFunctionData(functionFragment: "registerToken", values: [BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "registerTokenAdmin", values: [string]): string;
    encodeFunctionData(functionFragment: "registerUser", values: [string, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "registerUserAdmin", values: [string]): string;
    encodeFunctionData(functionFragment: "registerVerifier", values: [string, string]): string;
    encodeFunctionData(functionFragment: "removeAvailabilityVerifier", values: [string]): string;
    encodeFunctionData(functionFragment: "removeVerifier", values: [string]): string;
    encodeFunctionData(functionFragment: "unFreeze", values?: undefined): string;
    encodeFunctionData(functionFragment: "unregisterOperator", values: [string]): string;
    encodeFunctionData(functionFragment: "unregisterTokenAdmin", values: [string]): string;
    encodeFunctionData(functionFragment: "unregisterUserAdmin", values: [string]): string;
    encodeFunctionData(functionFragment: "updateState", values: [BigNumberish[], BigNumberish[]]): string;
    encodeFunctionData(functionFragment: "withdraw", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "withdrawAndMint", values: [BigNumberish, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "withdrawNft", values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "withdrawNftTo", values: [BigNumberish, BigNumberish, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: "withdrawTo", values: [BigNumberish, BigNumberish, string]): string;
    decodeFunctionResult(functionFragment: "announceAvailabilityVerifierRemovalIntent", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "announceVerifierRemovalIntent", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposit(uint256,uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposit(uint256,uint256,uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositCancel", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositERC20", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositEth", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositNft", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositNftReclaim", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositReclaim", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "escape", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "freezeRequest", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fullWithdrawalRequest", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAssetInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCancellationRequest", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDepositBalance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getEthKey", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getFullWithdrawalRequest", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastBatchId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOrderRoot", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOrderTreeHeight", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getQuantizedDepositBalance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getQuantum", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRegisteredAvailabilityVerifiers", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRegisteredVerifiers", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSequenceNumber", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVaultRoot", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVaultTreeHeight", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWithdrawalBalance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAvailabilityVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isFrozen", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isOperator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isTokenAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isUserAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mainAcceptGovernance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mainCancelNomination", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mainIsGovernor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mainNominateNewGovernor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mainRemoveGovernor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onERC721Received", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerAndDepositERC20", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerAndDepositEth", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerAvailabilityVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerOperator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerTokenAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerUser", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerUserAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "removeAvailabilityVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "removeVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unFreeze", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unregisterOperator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unregisterTokenAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unregisterUserAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawAndMint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawNft", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawNftTo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawTo", data: BytesLike): Result;
    events: {
        "LogDeposit(address,uint256,uint256,uint256,uint256,uint256)": EventFragment;
        "LogDepositCancel(uint256,uint256,uint256)": EventFragment;
        "LogDepositCancelReclaimed(uint256,uint256,uint256,uint256,uint256)": EventFragment;
        "LogDepositNftCancelReclaimed(uint256,uint256,uint256,uint256,uint256)": EventFragment;
        "LogFullWithdrawalRequest(uint256,uint256)": EventFragment;
        "LogMintWithdrawalPerformed(uint256,uint256,uint256,uint256,uint256)": EventFragment;
        "LogMintableWithdrawalAllowed(uint256,uint256,uint256)": EventFragment;
        "LogNftDeposit(address,uint256,uint256,uint256,uint256,uint256)": EventFragment;
        "LogNftWithdrawalAllowed(uint256,uint256)": EventFragment;
        "LogNftWithdrawalPerformed(uint256,uint256,uint256,uint256,address)": EventFragment;
        "LogRootUpdate(uint256,uint256,uint256,uint256)": EventFragment;
        "LogStateTransitionFact(bytes32)": EventFragment;
        "LogVaultBalanceChangeApplied(address,uint256,uint256,int256)": EventFragment;
        "LogWithdrawalAllowed(uint256,uint256,uint256,uint256)": EventFragment;
        "LogWithdrawalPerformed(uint256,uint256,uint256,uint256,address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "LogDeposit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogDepositCancel"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogDepositCancelReclaimed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogDepositNftCancelReclaimed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogFullWithdrawalRequest"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogMintWithdrawalPerformed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogMintableWithdrawalAllowed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogNftDeposit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogNftWithdrawalAllowed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogNftWithdrawalPerformed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogRootUpdate"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogStateTransitionFact"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogVaultBalanceChangeApplied"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogWithdrawalAllowed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogWithdrawalPerformed"): EventFragment;
}
interface LogDepositEventObject {
    depositorEthKey: string;
    starkKey: BigNumber;
    vaultId: BigNumber;
    assetType: BigNumber;
    nonQuantizedAmount: BigNumber;
    quantizedAmount: BigNumber;
}
declare type LogDepositEvent = TypedEvent<[
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], LogDepositEventObject>;
declare type LogDepositEventFilter = TypedEventFilter<LogDepositEvent>;
interface LogDepositCancelEventObject {
    starkKey: BigNumber;
    vaultId: BigNumber;
    assetId: BigNumber;
}
declare type LogDepositCancelEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber
], LogDepositCancelEventObject>;
declare type LogDepositCancelEventFilter = TypedEventFilter<LogDepositCancelEvent>;
interface LogDepositCancelReclaimedEventObject {
    starkKey: BigNumber;
    vaultId: BigNumber;
    assetType: BigNumber;
    nonQuantizedAmount: BigNumber;
    quantizedAmount: BigNumber;
}
declare type LogDepositCancelReclaimedEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], LogDepositCancelReclaimedEventObject>;
declare type LogDepositCancelReclaimedEventFilter = TypedEventFilter<LogDepositCancelReclaimedEvent>;
interface LogDepositNftCancelReclaimedEventObject {
    starkKey: BigNumber;
    vaultId: BigNumber;
    assetType: BigNumber;
    tokenId: BigNumber;
    assetId: BigNumber;
}
declare type LogDepositNftCancelReclaimedEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], LogDepositNftCancelReclaimedEventObject>;
declare type LogDepositNftCancelReclaimedEventFilter = TypedEventFilter<LogDepositNftCancelReclaimedEvent>;
interface LogFullWithdrawalRequestEventObject {
    starkKey: BigNumber;
    vaultId: BigNumber;
}
declare type LogFullWithdrawalRequestEvent = TypedEvent<[
    BigNumber,
    BigNumber
], LogFullWithdrawalRequestEventObject>;
declare type LogFullWithdrawalRequestEventFilter = TypedEventFilter<LogFullWithdrawalRequestEvent>;
interface LogMintWithdrawalPerformedEventObject {
    ownerKey: BigNumber;
    assetType: BigNumber;
    nonQuantizedAmount: BigNumber;
    quantizedAmount: BigNumber;
    assetId: BigNumber;
}
declare type LogMintWithdrawalPerformedEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], LogMintWithdrawalPerformedEventObject>;
declare type LogMintWithdrawalPerformedEventFilter = TypedEventFilter<LogMintWithdrawalPerformedEvent>;
interface LogMintableWithdrawalAllowedEventObject {
    ownerKey: BigNumber;
    assetId: BigNumber;
    quantizedAmount: BigNumber;
}
declare type LogMintableWithdrawalAllowedEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber
], LogMintableWithdrawalAllowedEventObject>;
declare type LogMintableWithdrawalAllowedEventFilter = TypedEventFilter<LogMintableWithdrawalAllowedEvent>;
interface LogNftDepositEventObject {
    depositorEthKey: string;
    starkKey: BigNumber;
    vaultId: BigNumber;
    assetType: BigNumber;
    tokenId: BigNumber;
    assetId: BigNumber;
}
declare type LogNftDepositEvent = TypedEvent<[
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], LogNftDepositEventObject>;
declare type LogNftDepositEventFilter = TypedEventFilter<LogNftDepositEvent>;
interface LogNftWithdrawalAllowedEventObject {
    ownerKey: BigNumber;
    assetId: BigNumber;
}
declare type LogNftWithdrawalAllowedEvent = TypedEvent<[
    BigNumber,
    BigNumber
], LogNftWithdrawalAllowedEventObject>;
declare type LogNftWithdrawalAllowedEventFilter = TypedEventFilter<LogNftWithdrawalAllowedEvent>;
interface LogNftWithdrawalPerformedEventObject {
    ownerKey: BigNumber;
    assetType: BigNumber;
    tokenId: BigNumber;
    assetId: BigNumber;
    recipient: string;
}
declare type LogNftWithdrawalPerformedEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string
], LogNftWithdrawalPerformedEventObject>;
declare type LogNftWithdrawalPerformedEventFilter = TypedEventFilter<LogNftWithdrawalPerformedEvent>;
interface LogRootUpdateEventObject {
    sequenceNumber: BigNumber;
    batchId: BigNumber;
    vaultRoot: BigNumber;
    orderRoot: BigNumber;
}
declare type LogRootUpdateEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], LogRootUpdateEventObject>;
declare type LogRootUpdateEventFilter = TypedEventFilter<LogRootUpdateEvent>;
interface LogStateTransitionFactEventObject {
    stateTransitionFact: string;
}
declare type LogStateTransitionFactEvent = TypedEvent<[
    string
], LogStateTransitionFactEventObject>;
declare type LogStateTransitionFactEventFilter = TypedEventFilter<LogStateTransitionFactEvent>;
interface LogVaultBalanceChangeAppliedEventObject {
    ethKey: string;
    assetId: BigNumber;
    vaultId: BigNumber;
    quantizedAmountChange: BigNumber;
}
declare type LogVaultBalanceChangeAppliedEvent = TypedEvent<[
    string,
    BigNumber,
    BigNumber,
    BigNumber
], LogVaultBalanceChangeAppliedEventObject>;
declare type LogVaultBalanceChangeAppliedEventFilter = TypedEventFilter<LogVaultBalanceChangeAppliedEvent>;
interface LogWithdrawalAllowedEventObject {
    ownerKey: BigNumber;
    assetType: BigNumber;
    nonQuantizedAmount: BigNumber;
    quantizedAmount: BigNumber;
}
declare type LogWithdrawalAllowedEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], LogWithdrawalAllowedEventObject>;
declare type LogWithdrawalAllowedEventFilter = TypedEventFilter<LogWithdrawalAllowedEvent>;
interface LogWithdrawalPerformedEventObject {
    ownerKey: BigNumber;
    assetType: BigNumber;
    nonQuantizedAmount: BigNumber;
    quantizedAmount: BigNumber;
    recipient: string;
}
declare type LogWithdrawalPerformedEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string
], LogWithdrawalPerformedEventObject>;
declare type LogWithdrawalPerformedEventFilter = TypedEventFilter<LogWithdrawalPerformedEvent>;
interface Core extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: CoreInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        announceAvailabilityVerifierRemovalIntent(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        announceVerifierRemovalIntent(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        "deposit(uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        "deposit(uint256,uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        depositCancel(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        depositERC20(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        depositEth(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        depositNft(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        depositNftReclaim(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        depositReclaim(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        escape(starkKey: BigNumberish, vaultId: BigNumberish, assetId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        freezeRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        fullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        getAssetInfo(assetType: BigNumberish, overrides?: CallOverrides): Promise<[string] & {
            assetInfo: string;
        }>;
        getCancellationRequest(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & {
            request: BigNumber;
        }>;
        getDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & {
            balance: BigNumber;
        }>;
        getEthKey(starkKey: BigNumberish, overrides?: CallOverrides): Promise<[string] & {
            ethKey: string;
        }>;
        getFullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & {
            res: BigNumber;
        }>;
        getLastBatchId(overrides?: CallOverrides): Promise<[BigNumber] & {
            batchId: BigNumber;
        }>;
        getOrderRoot(overrides?: CallOverrides): Promise<[BigNumber] & {
            root: BigNumber;
        }>;
        getOrderTreeHeight(overrides?: CallOverrides): Promise<[BigNumber] & {
            height: BigNumber;
        }>;
        getQuantizedDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & {
            balance: BigNumber;
        }>;
        getQuantum(presumedAssetType: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & {
            quantum: BigNumber;
        }>;
        getRegisteredAvailabilityVerifiers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        getRegisteredVerifiers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        getSequenceNumber(overrides?: CallOverrides): Promise<[BigNumber] & {
            seq: BigNumber;
        }>;
        getVaultRoot(overrides?: CallOverrides): Promise<[BigNumber] & {
            root: BigNumber;
        }>;
        getVaultTreeHeight(overrides?: CallOverrides): Promise<[BigNumber] & {
            height: BigNumber;
        }>;
        getWithdrawalBalance(ownerKey: BigNumberish, assetId: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & {
            balance: BigNumber;
        }>;
        isAvailabilityVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isFrozen(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isOperator(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isTokenAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isUserAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        mainAcceptGovernance(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        mainCancelNomination(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        mainIsGovernor(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        mainNominateNewGovernor(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        mainRemoveGovernor(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        onERC721Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerAndDepositERC20(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerAndDepositEth(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerAvailabilityVerifier(arg0: string, arg1: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerOperator(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerToken(arg0: BigNumberish, arg1: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerTokenAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerUser(arg0: string, arg1: BigNumberish, arg2: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerUserAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerVerifier(arg0: string, arg1: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        removeAvailabilityVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        removeVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unFreeze(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unregisterOperator(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unregisterTokenAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unregisterUserAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        updateState(publicInput: BigNumberish[], applicationData: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        withdraw(ownerKey: BigNumberish, assetType: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        withdrawAndMint(ownerKey: BigNumberish, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        withdrawNft(ownerKey: BigNumberish, assetType: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        withdrawNftTo(arg0: BigNumberish, arg1: BigNumberish, arg2: BigNumberish, arg3: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        withdrawTo(arg0: BigNumberish, arg1: BigNumberish, arg2: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    announceAvailabilityVerifierRemovalIntent(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    announceVerifierRemovalIntent(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    "deposit(uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    "deposit(uint256,uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    depositCancel(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    depositERC20(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    depositEth(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    depositNft(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    depositNftReclaim(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    depositReclaim(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    escape(starkKey: BigNumberish, vaultId: BigNumberish, assetId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    freezeRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    fullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    getAssetInfo(assetType: BigNumberish, overrides?: CallOverrides): Promise<string>;
    getCancellationRequest(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    getDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    getEthKey(starkKey: BigNumberish, overrides?: CallOverrides): Promise<string>;
    getFullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    getLastBatchId(overrides?: CallOverrides): Promise<BigNumber>;
    getOrderRoot(overrides?: CallOverrides): Promise<BigNumber>;
    getOrderTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;
    getQuantizedDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    getQuantum(presumedAssetType: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    getRegisteredAvailabilityVerifiers(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    getRegisteredVerifiers(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    getSequenceNumber(overrides?: CallOverrides): Promise<BigNumber>;
    getVaultRoot(overrides?: CallOverrides): Promise<BigNumber>;
    getVaultTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;
    getWithdrawalBalance(ownerKey: BigNumberish, assetId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    isAvailabilityVerifier(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isFrozen(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isOperator(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isTokenAdmin(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isUserAdmin(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isVerifier(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    mainAcceptGovernance(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    mainCancelNomination(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    mainIsGovernor(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    mainNominateNewGovernor(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    mainRemoveGovernor(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    onERC721Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerAndDepositERC20(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerAndDepositEth(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerAvailabilityVerifier(arg0: string, arg1: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerOperator(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerToken(arg0: BigNumberish, arg1: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerTokenAdmin(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerUser(arg0: string, arg1: BigNumberish, arg2: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerUserAdmin(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerVerifier(arg0: string, arg1: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    removeAvailabilityVerifier(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    removeVerifier(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unFreeze(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unregisterOperator(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unregisterTokenAdmin(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unregisterUserAdmin(arg0: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    updateState(publicInput: BigNumberish[], applicationData: BigNumberish[], overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    withdraw(ownerKey: BigNumberish, assetType: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    withdrawAndMint(ownerKey: BigNumberish, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    withdrawNft(ownerKey: BigNumberish, assetType: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    withdrawNftTo(arg0: BigNumberish, arg1: BigNumberish, arg2: BigNumberish, arg3: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    withdrawTo(arg0: BigNumberish, arg1: BigNumberish, arg2: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        announceAvailabilityVerifierRemovalIntent(arg0: string, overrides?: CallOverrides): Promise<void>;
        announceVerifierRemovalIntent(arg0: string, overrides?: CallOverrides): Promise<void>;
        "deposit(uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        "deposit(uint256,uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: CallOverrides): Promise<void>;
        depositCancel(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        depositERC20(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: CallOverrides): Promise<void>;
        depositEth(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        depositNft(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        depositNftReclaim(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        depositReclaim(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        escape(starkKey: BigNumberish, vaultId: BigNumberish, assetId: BigNumberish, quantizedAmount: BigNumberish, overrides?: CallOverrides): Promise<void>;
        freezeRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        fullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        getAssetInfo(assetType: BigNumberish, overrides?: CallOverrides): Promise<string>;
        getCancellationRequest(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getEthKey(starkKey: BigNumberish, overrides?: CallOverrides): Promise<string>;
        getFullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getLastBatchId(overrides?: CallOverrides): Promise<BigNumber>;
        getOrderRoot(overrides?: CallOverrides): Promise<BigNumber>;
        getOrderTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;
        getQuantizedDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getQuantum(presumedAssetType: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getRegisteredAvailabilityVerifiers(overrides?: CallOverrides): Promise<void>;
        getRegisteredVerifiers(overrides?: CallOverrides): Promise<void>;
        getSequenceNumber(overrides?: CallOverrides): Promise<BigNumber>;
        getVaultRoot(overrides?: CallOverrides): Promise<BigNumber>;
        getVaultTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;
        getWithdrawalBalance(ownerKey: BigNumberish, assetId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        isAvailabilityVerifier(arg0: string, overrides?: CallOverrides): Promise<void>;
        isFrozen(overrides?: CallOverrides): Promise<void>;
        isOperator(arg0: string, overrides?: CallOverrides): Promise<void>;
        isTokenAdmin(arg0: string, overrides?: CallOverrides): Promise<void>;
        isUserAdmin(arg0: string, overrides?: CallOverrides): Promise<void>;
        isVerifier(arg0: string, overrides?: CallOverrides): Promise<void>;
        mainAcceptGovernance(overrides?: CallOverrides): Promise<void>;
        mainCancelNomination(overrides?: CallOverrides): Promise<void>;
        mainIsGovernor(arg0: string, overrides?: CallOverrides): Promise<void>;
        mainNominateNewGovernor(arg0: string, overrides?: CallOverrides): Promise<void>;
        mainRemoveGovernor(arg0: string, overrides?: CallOverrides): Promise<void>;
        onERC721Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BytesLike, overrides?: CallOverrides): Promise<void>;
        registerAndDepositERC20(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: CallOverrides): Promise<void>;
        registerAndDepositEth(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        registerAvailabilityVerifier(arg0: string, arg1: string, overrides?: CallOverrides): Promise<void>;
        registerOperator(arg0: string, overrides?: CallOverrides): Promise<void>;
        registerToken(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<void>;
        registerTokenAdmin(arg0: string, overrides?: CallOverrides): Promise<void>;
        registerUser(arg0: string, arg1: BigNumberish, arg2: BytesLike, overrides?: CallOverrides): Promise<void>;
        registerUserAdmin(arg0: string, overrides?: CallOverrides): Promise<void>;
        registerVerifier(arg0: string, arg1: string, overrides?: CallOverrides): Promise<void>;
        removeAvailabilityVerifier(arg0: string, overrides?: CallOverrides): Promise<void>;
        removeVerifier(arg0: string, overrides?: CallOverrides): Promise<void>;
        unFreeze(overrides?: CallOverrides): Promise<void>;
        unregisterOperator(arg0: string, overrides?: CallOverrides): Promise<void>;
        unregisterTokenAdmin(arg0: string, overrides?: CallOverrides): Promise<void>;
        unregisterUserAdmin(arg0: string, overrides?: CallOverrides): Promise<void>;
        updateState(publicInput: BigNumberish[], applicationData: BigNumberish[], overrides?: CallOverrides): Promise<void>;
        withdraw(ownerKey: BigNumberish, assetType: BigNumberish, overrides?: CallOverrides): Promise<void>;
        withdrawAndMint(ownerKey: BigNumberish, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: CallOverrides): Promise<void>;
        withdrawNft(ownerKey: BigNumberish, assetType: BigNumberish, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        withdrawNftTo(arg0: BigNumberish, arg1: BigNumberish, arg2: BigNumberish, arg3: string, overrides?: CallOverrides): Promise<void>;
        withdrawTo(arg0: BigNumberish, arg1: BigNumberish, arg2: string, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "LogDeposit(address,uint256,uint256,uint256,uint256,uint256)"(depositorEthKey?: null, starkKey?: null, vaultId?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null): LogDepositEventFilter;
        LogDeposit(depositorEthKey?: null, starkKey?: null, vaultId?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null): LogDepositEventFilter;
        "LogDepositCancel(uint256,uint256,uint256)"(starkKey?: null, vaultId?: null, assetId?: null): LogDepositCancelEventFilter;
        LogDepositCancel(starkKey?: null, vaultId?: null, assetId?: null): LogDepositCancelEventFilter;
        "LogDepositCancelReclaimed(uint256,uint256,uint256,uint256,uint256)"(starkKey?: null, vaultId?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null): LogDepositCancelReclaimedEventFilter;
        LogDepositCancelReclaimed(starkKey?: null, vaultId?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null): LogDepositCancelReclaimedEventFilter;
        "LogDepositNftCancelReclaimed(uint256,uint256,uint256,uint256,uint256)"(starkKey?: null, vaultId?: null, assetType?: null, tokenId?: null, assetId?: null): LogDepositNftCancelReclaimedEventFilter;
        LogDepositNftCancelReclaimed(starkKey?: null, vaultId?: null, assetType?: null, tokenId?: null, assetId?: null): LogDepositNftCancelReclaimedEventFilter;
        "LogFullWithdrawalRequest(uint256,uint256)"(starkKey?: null, vaultId?: null): LogFullWithdrawalRequestEventFilter;
        LogFullWithdrawalRequest(starkKey?: null, vaultId?: null): LogFullWithdrawalRequestEventFilter;
        "LogMintWithdrawalPerformed(uint256,uint256,uint256,uint256,uint256)"(ownerKey?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null, assetId?: null): LogMintWithdrawalPerformedEventFilter;
        LogMintWithdrawalPerformed(ownerKey?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null, assetId?: null): LogMintWithdrawalPerformedEventFilter;
        "LogMintableWithdrawalAllowed(uint256,uint256,uint256)"(ownerKey?: null, assetId?: null, quantizedAmount?: null): LogMintableWithdrawalAllowedEventFilter;
        LogMintableWithdrawalAllowed(ownerKey?: null, assetId?: null, quantizedAmount?: null): LogMintableWithdrawalAllowedEventFilter;
        "LogNftDeposit(address,uint256,uint256,uint256,uint256,uint256)"(depositorEthKey?: null, starkKey?: null, vaultId?: null, assetType?: null, tokenId?: null, assetId?: null): LogNftDepositEventFilter;
        LogNftDeposit(depositorEthKey?: null, starkKey?: null, vaultId?: null, assetType?: null, tokenId?: null, assetId?: null): LogNftDepositEventFilter;
        "LogNftWithdrawalAllowed(uint256,uint256)"(ownerKey?: null, assetId?: null): LogNftWithdrawalAllowedEventFilter;
        LogNftWithdrawalAllowed(ownerKey?: null, assetId?: null): LogNftWithdrawalAllowedEventFilter;
        "LogNftWithdrawalPerformed(uint256,uint256,uint256,uint256,address)"(ownerKey?: null, assetType?: null, tokenId?: null, assetId?: null, recipient?: null): LogNftWithdrawalPerformedEventFilter;
        LogNftWithdrawalPerformed(ownerKey?: null, assetType?: null, tokenId?: null, assetId?: null, recipient?: null): LogNftWithdrawalPerformedEventFilter;
        "LogRootUpdate(uint256,uint256,uint256,uint256)"(sequenceNumber?: null, batchId?: null, vaultRoot?: null, orderRoot?: null): LogRootUpdateEventFilter;
        LogRootUpdate(sequenceNumber?: null, batchId?: null, vaultRoot?: null, orderRoot?: null): LogRootUpdateEventFilter;
        "LogStateTransitionFact(bytes32)"(stateTransitionFact?: null): LogStateTransitionFactEventFilter;
        LogStateTransitionFact(stateTransitionFact?: null): LogStateTransitionFactEventFilter;
        "LogVaultBalanceChangeApplied(address,uint256,uint256,int256)"(ethKey?: null, assetId?: null, vaultId?: null, quantizedAmountChange?: null): LogVaultBalanceChangeAppliedEventFilter;
        LogVaultBalanceChangeApplied(ethKey?: null, assetId?: null, vaultId?: null, quantizedAmountChange?: null): LogVaultBalanceChangeAppliedEventFilter;
        "LogWithdrawalAllowed(uint256,uint256,uint256,uint256)"(ownerKey?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null): LogWithdrawalAllowedEventFilter;
        LogWithdrawalAllowed(ownerKey?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null): LogWithdrawalAllowedEventFilter;
        "LogWithdrawalPerformed(uint256,uint256,uint256,uint256,address)"(ownerKey?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null, recipient?: null): LogWithdrawalPerformedEventFilter;
        LogWithdrawalPerformed(ownerKey?: null, assetType?: null, nonQuantizedAmount?: null, quantizedAmount?: null, recipient?: null): LogWithdrawalPerformedEventFilter;
    };
    estimateGas: {
        announceAvailabilityVerifierRemovalIntent(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        announceVerifierRemovalIntent(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        "deposit(uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        "deposit(uint256,uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        depositCancel(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        depositERC20(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        depositEth(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        depositNft(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        depositNftReclaim(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        depositReclaim(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        escape(starkKey: BigNumberish, vaultId: BigNumberish, assetId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        freezeRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        fullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        getAssetInfo(assetType: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getCancellationRequest(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getEthKey(starkKey: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getFullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getLastBatchId(overrides?: CallOverrides): Promise<BigNumber>;
        getOrderRoot(overrides?: CallOverrides): Promise<BigNumber>;
        getOrderTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;
        getQuantizedDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getQuantum(presumedAssetType: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getRegisteredAvailabilityVerifiers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        getRegisteredVerifiers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        getSequenceNumber(overrides?: CallOverrides): Promise<BigNumber>;
        getVaultRoot(overrides?: CallOverrides): Promise<BigNumber>;
        getVaultTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;
        getWithdrawalBalance(ownerKey: BigNumberish, assetId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        isAvailabilityVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isFrozen(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isOperator(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isTokenAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isUserAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        mainAcceptGovernance(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        mainCancelNomination(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        mainIsGovernor(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        mainNominateNewGovernor(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        mainRemoveGovernor(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        onERC721Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerAndDepositERC20(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerAndDepositEth(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerAvailabilityVerifier(arg0: string, arg1: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerOperator(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerToken(arg0: BigNumberish, arg1: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerTokenAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerUser(arg0: string, arg1: BigNumberish, arg2: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerUserAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerVerifier(arg0: string, arg1: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        removeAvailabilityVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        removeVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unFreeze(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unregisterOperator(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unregisterTokenAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unregisterUserAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        updateState(publicInput: BigNumberish[], applicationData: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        withdraw(ownerKey: BigNumberish, assetType: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        withdrawAndMint(ownerKey: BigNumberish, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        withdrawNft(ownerKey: BigNumberish, assetType: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        withdrawNftTo(arg0: BigNumberish, arg1: BigNumberish, arg2: BigNumberish, arg3: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        withdrawTo(arg0: BigNumberish, arg1: BigNumberish, arg2: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        announceAvailabilityVerifierRemovalIntent(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        announceVerifierRemovalIntent(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        "deposit(uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        "deposit(uint256,uint256,uint256,uint256)"(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        depositCancel(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        depositERC20(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        depositEth(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        depositNft(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        depositNftReclaim(starkKey: BigNumberish, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        depositReclaim(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        escape(starkKey: BigNumberish, vaultId: BigNumberish, assetId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        freezeRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        fullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        getAssetInfo(assetType: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCancellationRequest(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getEthKey(starkKey: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getFullWithdrawalRequest(starkKey: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastBatchId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOrderRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOrderTreeHeight(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getQuantizedDepositBalance(starkKey: BigNumberish, assetId: BigNumberish, vaultId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getQuantum(presumedAssetType: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRegisteredAvailabilityVerifiers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        getRegisteredVerifiers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        getSequenceNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVaultRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVaultTreeHeight(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWithdrawalBalance(ownerKey: BigNumberish, assetId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isAvailabilityVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isFrozen(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isOperator(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isTokenAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isUserAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        mainAcceptGovernance(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        mainCancelNomination(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        mainIsGovernor(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        mainNominateNewGovernor(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        mainRemoveGovernor(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        onERC721Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerAndDepositERC20(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, quantizedAmount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerAndDepositEth(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerAvailabilityVerifier(arg0: string, arg1: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerOperator(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerToken(arg0: BigNumberish, arg1: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerTokenAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerUser(arg0: string, arg1: BigNumberish, arg2: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerUserAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerVerifier(arg0: string, arg1: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        removeAvailabilityVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        removeVerifier(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unFreeze(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unregisterOperator(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unregisterTokenAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unregisterUserAdmin(arg0: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        updateState(publicInput: BigNumberish[], applicationData: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        withdraw(ownerKey: BigNumberish, assetType: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        withdrawAndMint(ownerKey: BigNumberish, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        withdrawNft(ownerKey: BigNumberish, assetType: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        withdrawNftTo(arg0: BigNumberish, arg1: BigNumberish, arg2: BigNumberish, arg3: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        withdrawTo(arg0: BigNumberish, arg1: BigNumberish, arg2: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface RegistrationInterface extends utils.Interface {
    functions: {
        "imx()": FunctionFragment;
        "isRegistered(uint256)": FunctionFragment;
        "registerAndDepositNft(address,uint256,bytes,uint256,uint256,uint256)": FunctionFragment;
        "registerAndWithdraw(address,uint256,bytes,uint256)": FunctionFragment;
        "registerAndWithdrawNft(address,uint256,bytes,uint256,uint256)": FunctionFragment;
        "registerAndWithdrawNftTo(address,uint256,bytes,uint256,uint256,address)": FunctionFragment;
        "registerAndWithdrawTo(address,uint256,bytes,uint256,address)": FunctionFragment;
        "regsiterAndWithdrawAndMint(address,uint256,bytes,uint256,bytes)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "imx" | "isRegistered" | "registerAndDepositNft" | "registerAndWithdraw" | "registerAndWithdrawNft" | "registerAndWithdrawNftTo" | "registerAndWithdrawTo" | "regsiterAndWithdrawAndMint"): FunctionFragment;
    encodeFunctionData(functionFragment: "imx", values?: undefined): string;
    encodeFunctionData(functionFragment: "isRegistered", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "registerAndDepositNft", values: [
        string,
        BigNumberish,
        BytesLike,
        BigNumberish,
        BigNumberish,
        BigNumberish
    ]): string;
    encodeFunctionData(functionFragment: "registerAndWithdraw", values: [string, BigNumberish, BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "registerAndWithdrawNft", values: [string, BigNumberish, BytesLike, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "registerAndWithdrawNftTo", values: [
        string,
        BigNumberish,
        BytesLike,
        BigNumberish,
        BigNumberish,
        string
    ]): string;
    encodeFunctionData(functionFragment: "registerAndWithdrawTo", values: [string, BigNumberish, BytesLike, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: "regsiterAndWithdrawAndMint", values: [string, BigNumberish, BytesLike, BigNumberish, BytesLike]): string;
    decodeFunctionResult(functionFragment: "imx", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isRegistered", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerAndDepositNft", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerAndWithdraw", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerAndWithdrawNft", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerAndWithdrawNftTo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerAndWithdrawTo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "regsiterAndWithdrawAndMint", data: BytesLike): Result;
    events: {};
}
interface Registration extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: RegistrationInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        imx(overrides?: CallOverrides): Promise<[string]>;
        isRegistered(starkKey: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>;
        registerAndDepositNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerAndWithdraw(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerAndWithdrawNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerAndWithdrawNftTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, recipient: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        registerAndWithdrawTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, recipient: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        regsiterAndWithdrawAndMint(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    imx(overrides?: CallOverrides): Promise<string>;
    isRegistered(starkKey: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
    registerAndDepositNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerAndWithdraw(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerAndWithdrawNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerAndWithdrawNftTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, recipient: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    registerAndWithdrawTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, recipient: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    regsiterAndWithdrawAndMint(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        imx(overrides?: CallOverrides): Promise<string>;
        isRegistered(starkKey: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
        registerAndDepositNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        registerAndWithdraw(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, overrides?: CallOverrides): Promise<void>;
        registerAndWithdrawNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        registerAndWithdrawNftTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, recipient: string, overrides?: CallOverrides): Promise<void>;
        registerAndWithdrawTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, recipient: string, overrides?: CallOverrides): Promise<void>;
        regsiterAndWithdrawAndMint(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: CallOverrides): Promise<void>;
    };
    filters: {};
    estimateGas: {
        imx(overrides?: CallOverrides): Promise<BigNumber>;
        isRegistered(starkKey: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        registerAndDepositNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerAndWithdraw(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerAndWithdrawNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerAndWithdrawNftTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, recipient: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        registerAndWithdrawTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, recipient: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        regsiterAndWithdrawAndMint(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        imx(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isRegistered(starkKey: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        registerAndDepositNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, vaultId: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerAndWithdraw(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerAndWithdrawNft(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerAndWithdrawNftTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, tokenId: BigNumberish, recipient: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        registerAndWithdrawTo(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, recipient: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        regsiterAndWithdrawAndMint(ethKey: string, starkKey: BigNumberish, signature: BytesLike, assetType: BigNumberish, mintingBlob: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare class IERC20__factory {
    static readonly abi: ({
        anonymous: boolean;
        inputs: {
            indexed: boolean;
            internalType: string;
            name: string;
            type: string;
        }[];
        name: string;
        type: string;
        outputs?: undefined;
        stateMutability?: undefined;
    } | {
        inputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        anonymous?: undefined;
    })[];
    static createInterface(): IERC20Interface;
    static connect(address: string, signerOrProvider: Signer | Provider): IERC20;
}

declare class IERC721__factory {
    static readonly abi: ({
        anonymous: boolean;
        inputs: {
            indexed: boolean;
            internalType: string;
            name: string;
            type: string;
        }[];
        name: string;
        type: string;
        outputs?: undefined;
        stateMutability?: undefined;
    } | {
        inputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        anonymous?: undefined;
    })[];
    static createInterface(): IERC721Interface;
    static connect(address: string, signerOrProvider: Signer | Provider): IERC721;
}

declare class Core__factory {
    static readonly abi: ({
        anonymous: boolean;
        inputs: {
            indexed: boolean;
            internalType: string;
            name: string;
            type: string;
        }[];
        name: string;
        type: string;
        outputs?: undefined;
        stateMutability?: undefined;
    } | {
        inputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        anonymous?: undefined;
    })[];
    static createInterface(): CoreInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): Core;
}

declare type RegistrationConstructorParams = [signer?: Signer] | ConstructorParameters<typeof ContractFactory>;
declare class Registration__factory extends ContractFactory {
    constructor(...args: RegistrationConstructorParams);
    deploy(_imx: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<Registration>;
    getDeployTransaction(_imx: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): TransactionRequest;
    attach(address: string): Registration;
    connect(signer: Signer): Registration__factory;
    static readonly bytecode = "0x60806040523480156200001157600080fd5b5060405162001313380380620013138339818101604052810190620000379190620000fc565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506200012e565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000620000b08262000083565b9050919050565b6000620000c482620000a3565b9050919050565b620000d681620000b7565b8114620000e257600080fd5b50565b600081519050620000f681620000cb565b92915050565b6000602082840312156200011557620001146200007e565b5b60006200012584828501620000e5565b91505092915050565b6111d5806200013e6000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c80634280d50a1161005b5780634280d50a146100ff5780634627d5981461011b578063579a698814610137578063ea864adf1461016757610088565b80630a9c3beb1461008d5780630f08025f146100a95780631259cc6c146100c7578063352eb84c146100e3575b600080fd5b6100a760048036038101906100a29190610a72565b610183565b005b6100b16102ae565b6040516100be9190610b8d565b60405180910390f35b6100e160048036038101906100dc9190610ba8565b6102d2565b005b6100fd60048036038101906100f89190610c57565b6103fd565b005b61011960048036038101906101149190610cf1565b610525565b005b61013560048036038101906101309190610da0565b610650565b005b610151600480360381019061014c9190610e3a565b610778565b60405161015e9190610e82565b60405180910390f35b610181600480360381019061017c9190610e9d565b61084a565b005b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663dd2414d4888888886040518563ffffffff1660e01b81526004016101e29493929190610fa1565b600060405180830381600087803b1580156101fc57600080fd5b505af1158015610210573d6000803e3d6000fd5b5050505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d91443b7878585856040518563ffffffff1660e01b81526004016102739493929190610fe1565b600060405180830381600087803b15801561028d57600080fd5b505af11580156102a1573d6000803e3d6000fd5b5050505050505050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663dd2414d4888888886040518563ffffffff1660e01b81526004016103319493929190610fa1565b600060405180830381600087803b15801561034b57600080fd5b505af115801561035f573d6000803e3d6000fd5b5050505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ebef0fd0878585856040518563ffffffff1660e01b81526004016103c29493929190611021565b600060405180830381600087803b1580156103dc57600080fd5b505af11580156103f0573d6000803e3d6000fd5b5050505050505050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663dd2414d4878787876040518563ffffffff1660e01b815260040161045c9493929190610fa1565b600060405180830381600087803b15801561047657600080fd5b505af115801561048a573d6000803e3d6000fd5b5050505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663019b417a8684846040518463ffffffff1660e01b81526004016104eb93929190611066565b600060405180830381600087803b15801561050557600080fd5b505af1158015610519573d6000803e3d6000fd5b50505050505050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663dd2414d4888888886040518563ffffffff1660e01b81526004016105849493929190610fa1565b600060405180830381600087803b15801561059e57600080fd5b505af11580156105b2573d6000803e3d6000fd5b5050505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ae1cdde6878585856040518563ffffffff1660e01b8152600401610615949392919061109d565b600060405180830381600087803b15801561062f57600080fd5b505af1158015610643573d6000803e3d6000fd5b5050505050505050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663dd2414d4878787876040518563ffffffff1660e01b81526004016106af9493929190610fa1565b600060405180830381600087803b1580156106c957600080fd5b505af11580156106dd573d6000803e3d6000fd5b5050505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166314cd70e48684846040518463ffffffff1660e01b815260040161073e939291906110e2565b600060405180830381600087803b15801561075857600080fd5b505af115801561076c573d6000803e3d6000fd5b50505050505050505050565b60008073ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631dbd1da7846040518263ffffffff1660e01b81526004016107ea9190611119565b602060405180830381865afa158015610807573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061082b9190611149565b73ffffffffffffffffffffffffffffffffffffffff1614159050919050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663dd2414d4868686866040518563ffffffff1660e01b81526004016108a99493929190610fa1565b600060405180830381600087803b1580156108c357600080fd5b505af11580156108d7573d6000803e3d6000fd5b5050505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663441a3e7085836040518363ffffffff1660e01b8152600401610936929190611176565b600060405180830381600087803b15801561095057600080fd5b505af1158015610964573d6000803e3d6000fd5b505050505050505050565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006109a482610979565b9050919050565b6109b481610999565b81146109bf57600080fd5b50565b6000813590506109d1816109ab565b92915050565b6000819050919050565b6109ea816109d7565b81146109f557600080fd5b50565b600081359050610a07816109e1565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f840112610a3257610a31610a0d565b5b8235905067ffffffffffffffff811115610a4f57610a4e610a12565b5b602083019150836001820283011115610a6b57610a6a610a17565b5b9250929050565b600080600080600080600060a0888a031215610a9157610a9061096f565b5b6000610a9f8a828b016109c2565b9750506020610ab08a828b016109f8565b965050604088013567ffffffffffffffff811115610ad157610ad0610974565b5b610add8a828b01610a1c565b95509550506060610af08a828b016109f8565b935050608088013567ffffffffffffffff811115610b1157610b10610974565b5b610b1d8a828b01610a1c565b925092505092959891949750929550565b6000819050919050565b6000610b53610b4e610b4984610979565b610b2e565b610979565b9050919050565b6000610b6582610b38565b9050919050565b6000610b7782610b5a565b9050919050565b610b8781610b6c565b82525050565b6000602082019050610ba26000830184610b7e565b92915050565b600080600080600080600060c0888a031215610bc757610bc661096f565b5b6000610bd58a828b016109c2565b9750506020610be68a828b016109f8565b965050604088013567ffffffffffffffff811115610c0757610c06610974565b5b610c138a828b01610a1c565b95509550506060610c268a828b016109f8565b9350506080610c378a828b016109f8565b92505060a0610c488a828b016109c2565b91505092959891949750929550565b60008060008060008060a08789031215610c7457610c7361096f565b5b6000610c8289828a016109c2565b9650506020610c9389828a016109f8565b955050604087013567ffffffffffffffff811115610cb457610cb3610974565b5b610cc089828a01610a1c565b94509450506060610cd389828a016109f8565b9250506080610ce489828a016109f8565b9150509295509295509295565b600080600080600080600060c0888a031215610d1057610d0f61096f565b5b6000610d1e8a828b016109c2565b9750506020610d2f8a828b016109f8565b965050604088013567ffffffffffffffff811115610d5057610d4f610974565b5b610d5c8a828b01610a1c565b95509550506060610d6f8a828b016109f8565b9350506080610d808a828b016109f8565b92505060a0610d918a828b016109f8565b91505092959891949750929550565b60008060008060008060a08789031215610dbd57610dbc61096f565b5b6000610dcb89828a016109c2565b9650506020610ddc89828a016109f8565b955050604087013567ffffffffffffffff811115610dfd57610dfc610974565b5b610e0989828a01610a1c565b94509450506060610e1c89828a016109f8565b9250506080610e2d89828a016109c2565b9150509295509295509295565b600060208284031215610e5057610e4f61096f565b5b6000610e5e848285016109f8565b91505092915050565b60008115159050919050565b610e7c81610e67565b82525050565b6000602082019050610e976000830184610e73565b92915050565b600080600080600060808688031215610eb957610eb861096f565b5b6000610ec7888289016109c2565b9550506020610ed8888289016109f8565b945050604086013567ffffffffffffffff811115610ef957610ef8610974565b5b610f0588828901610a1c565b93509350506060610f18888289016109f8565b9150509295509295909350565b610f2e81610999565b82525050565b610f3d816109d7565b82525050565b600082825260208201905092915050565b82818337600083830152505050565b6000601f19601f8301169050919050565b6000610f808385610f43565b9350610f8d838584610f54565b610f9683610f63565b840190509392505050565b6000606082019050610fb66000830187610f25565b610fc36020830186610f34565b8181036040830152610fd6818486610f74565b905095945050505050565b6000606082019050610ff66000830187610f34565b6110036020830186610f34565b8181036040830152611016818486610f74565b905095945050505050565b60006080820190506110366000830187610f34565b6110436020830186610f34565b6110506040830185610f34565b61105d6060830184610f25565b95945050505050565b600060608201905061107b6000830186610f34565b6110886020830185610f34565b6110956040830184610f34565b949350505050565b60006080820190506110b26000830187610f34565b6110bf6020830186610f34565b6110cc6040830185610f34565b6110d96060830184610f34565b95945050505050565b60006060820190506110f76000830186610f34565b6111046020830185610f34565b6111116040830184610f25565b949350505050565b600060208201905061112e6000830184610f34565b92915050565b600081519050611143816109ab565b92915050565b60006020828403121561115f5761115e61096f565b5b600061116d84828501611134565b91505092915050565b600060408201905061118b6000830185610f34565b6111986020830184610f34565b939250505056fea264697066735822122032218b31f9c0e88bb1991ae2275255c3d0cb01b4bf63a689bcaeccdcc791192c64736f6c634300080b0033";
    static readonly abi: ({
        inputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        name?: undefined;
        outputs?: undefined;
    } | {
        inputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
    })[];
    static createInterface(): RegistrationInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): Registration;
}

declare namespace exportContracts_d {
  export {
    Core__factory as Core,
    Registration__factory as Registration,
    IERC20__factory as IERC20,
    IERC721__factory as IERC721,
  };
}

/**
 * Generates a new Stark private key
 * @returns the private key as a hex string
 */
declare function generateStarkPrivateKey(): string;
/**
 * Generates a deterministic Stark private key from the provided signer.
 * @returns the private key as a hex string
 */
declare function generateLegacyStarkPrivateKey(signer: Signer$1): Promise<string>;

/**
 * An abstraction of a Stark account, which can be used to sign messages and transactions on StarkEx to execute state changing operations
 */
interface StarkSigner {
    /**
     * Signs the prefixed-message
     * @params message - this must be a UTF8-message
     * @example "0x1234"
     * @returns the signed prefixed-message
     */
    signMessage(message: string): Promise<string>;
    /**
     * Get the Signer address
     * @returns the Signer's checksum address
     */
    getAddress(): string | Promise<string>;
}
/**
 * A pair of Signers
 */
interface WalletConnection {
    /**
     * The L1 signer
     */
    ethSigner: Signer$1;
    /**
     * The L2 signer
     */
    starkSigner: StarkSigner;
}

/**
 * An ERC20 token
 */
interface ERC20Token {
    type: 'ERC20';
    tokenAddress: string;
}
/**
 * An ERC721 token
 */
interface ERC721Token {
    type: 'ERC721';
    tokenId: string;
    tokenAddress: string;
}
/**
 * An ETH token
 */
interface ETHToken {
    type: 'ETH';
}
/**
 * An amount of ETH token of unit Wei
 */
interface ETHAmount extends ETHToken {
    /**
     * An amount in unit Wei
     */
    amount: string;
}
/**
 * The token details and amount of ERC20 token units
 */
interface ERC20Amount extends ERC20Token {
    /**
     * An amount in units for the given ERC20 token
     */
    amount: string;
}
/**
 * Union type that represents all token types
 */
declare type AnyToken = ETHToken | ERC721Token | ERC20Token;
/**
 * Union type that represents all token type amounts
 */
declare type TokenAmount = ETHAmount | ERC20Amount | ERC721Token;
/**
 * Union type that represents exchange token type amounts
 */
declare type ExchangeTokenAmount = ETHAmount | ERC20Amount;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RequestArgs
 */
interface RequestArgs {
    url: string;
    options: AxiosRequestConfig;
}
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI {
    protected basePath: string;
    protected axios: AxiosInstance;
    protected configuration: Configuration | undefined;
    constructor(configuration?: Configuration, basePath?: string, axios?: AxiosInstance);
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface APIError
 */
interface APIError {
    /**
     * The error code
     * @type {string}
     * @memberof APIError
     */
    'code': string;
    /**
     * The error details
     * @type {string}
     * @memberof APIError
     */
    'details'?: string;
    /**
     * The error message
     * @type {string}
     * @memberof APIError
     */
    'message': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataSchemaRequest
 */
interface MetadataSchemaRequest {
    /**
     * Sets the metadata as filterable
     * @type {boolean}
     * @memberof MetadataSchemaRequest
     */
    'filterable'?: boolean;
    /**
     * Name of the metadata key
     * @type {string}
     * @memberof MetadataSchemaRequest
     */
    'name': string;
    /**
     * Type of the metadata. Values: \"enum\", \"text\", \"boolean\", \"continuous\", \"discrete\" | Default: \"text\". Src: https://docs.x.immutable.com/docs/asset-metadata#property-type-mapping
     * @type {string}
     * @memberof MetadataSchemaRequest
     */
    'type'?: MetadataSchemaRequestTypeEnum;
}
declare const MetadataSchemaRequestTypeEnum: {
    readonly Enum: "enum";
    readonly Text: "text";
    readonly Boolean: "boolean";
    readonly Continuous: "continuous";
    readonly Discrete: "discrete";
};
declare type MetadataSchemaRequestTypeEnum = typeof MetadataSchemaRequestTypeEnum[keyof typeof MetadataSchemaRequestTypeEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface AddMetadataSchemaToCollectionRequest
 */
interface AddMetadataSchemaToCollectionRequest {
    /**
     * Not required from API user
     * @type {string}
     * @memberof AddMetadataSchemaToCollectionRequest
     */
    'contract_address'?: string;
    /**
     * The metadata container
     * @type {Array<MetadataSchemaRequest>}
     * @memberof AddMetadataSchemaToCollectionRequest
     */
    'metadata': Array<MetadataSchemaRequest>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface AggregateLimit
 */
interface AggregateLimit {
    /**
     * Max transaction amount
     * @type {number}
     * @memberof AggregateLimit
     */
    'max_amount'?: number;
    /**
     * Min transaction amount
     * @type {number}
     * @memberof AggregateLimit
     */
    'min_amount'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CollectionDetails
 */
interface CollectionDetails {
    /**
     * URL of the icon of the collection
     * @type {string}
     * @memberof CollectionDetails
     */
    'icon_url': string | null;
    /**
     * Name of the collection
     * @type {string}
     * @memberof CollectionDetails
     */
    'name': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Fee
 */
interface Fee {
    /**
     * Wallet address
     * @type {string}
     * @memberof Fee
     */
    'address': string;
    /**
     * The percentage of fee
     * @type {number}
     * @memberof Fee
     */
    'percentage': number;
    /**
     * Type of fee. Examples: `royalty`, `maker`, `taker` or `protocol`
     * @type {string}
     * @memberof Fee
     */
    'type': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface OrderDetails
 */
interface OrderDetails {
    /**
     * Buy orders for this asset
     * @type {Array<object>}
     * @memberof OrderDetails
     */
    'buy_orders'?: Array<object>;
    /**
     * Sell orders for this asset
     * @type {Array<object>}
     * @memberof OrderDetails
     */
    'sell_orders'?: Array<object>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Asset
 */
interface Asset {
    /**
     *
     * @type {CollectionDetails}
     * @memberof Asset
     */
    'collection': CollectionDetails;
    /**
     * Timestamp of when the asset was created
     * @type {string}
     * @memberof Asset
     */
    'created_at': string | null;
    /**
     * Description of this asset
     * @type {string}
     * @memberof Asset
     */
    'description': string | null;
    /**
     * Royalties to pay on this asset operations
     * @type {Array<Fee>}
     * @memberof Asset
     */
    'fees'?: Array<Fee>;
    /**
     * [DEPRECATED] Internal Immutable X Token ID
     * @type {string}
     * @memberof Asset
     */
    'id'?: string;
    /**
     * URL of the image which should be used for this asset
     * @type {string}
     * @memberof Asset
     */
    'image_url': string | null;
    /**
     * Metadata of this asset
     * @type {object}
     * @memberof Asset
     */
    'metadata': object | null;
    /**
     * Name of this asset
     * @type {string}
     * @memberof Asset
     */
    'name': string | null;
    /**
     *
     * @type {OrderDetails}
     * @memberof Asset
     */
    'orders'?: OrderDetails;
    /**
     * Status of this asset (where it is in the system)
     * @type {string}
     * @memberof Asset
     */
    'status': string;
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof Asset
     */
    'token_address': string;
    /**
     * ERC721 Token ID of this asset
     * @type {string}
     * @memberof Asset
     */
    'token_id': string;
    /**
     * Timestamp of when the asset was updated
     * @type {string}
     * @memberof Asset
     */
    'updated_at': string | null;
    /**
     * URI to access this asset externally to Immutable X
     * @type {string}
     * @memberof Asset
     */
    'uri': string | null;
    /**
     * Ethereum address of the user who owns this asset
     * @type {string}
     * @memberof Asset
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface AssetProperties
 */
interface AssetProperties {
    /**
     *
     * @type {CollectionDetails}
     * @memberof AssetProperties
     */
    'collection'?: CollectionDetails;
    /**
     * Image URL of this asset
     * @type {string}
     * @memberof AssetProperties
     */
    'image_url'?: string;
    /**
     * Name of this asset
     * @type {string}
     * @memberof AssetProperties
     */
    'name'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface AssetWithOrders
 */
interface AssetWithOrders {
    /**
     *
     * @type {CollectionDetails}
     * @memberof AssetWithOrders
     */
    'collection': CollectionDetails;
    /**
     * Timestamp of when the asset was created
     * @type {string}
     * @memberof AssetWithOrders
     */
    'created_at': string | null;
    /**
     * Description of this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'description': string | null;
    /**
     * Royalties to pay on this asset operations
     * @type {Array<Fee>}
     * @memberof AssetWithOrders
     */
    'fees'?: Array<Fee>;
    /**
     * [DEPRECATED] Internal Immutable X Token ID
     * @type {string}
     * @memberof AssetWithOrders
     */
    'id'?: string;
    /**
     * URL of the image which should be used for this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'image_url': string | null;
    /**
     * Metadata of this asset
     * @type {object}
     * @memberof AssetWithOrders
     */
    'metadata': object | null;
    /**
     * Name of this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'name': string | null;
    /**
     *
     * @type {OrderDetails}
     * @memberof AssetWithOrders
     */
    'orders'?: OrderDetails;
    /**
     * Status of this asset (where it is in the system)
     * @type {string}
     * @memberof AssetWithOrders
     */
    'status': string;
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof AssetWithOrders
     */
    'token_address': string;
    /**
     * ERC721 Token ID of this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'token_id': string;
    /**
     * Timestamp of when the asset was updated
     * @type {string}
     * @memberof AssetWithOrders
     */
    'updated_at': string | null;
    /**
     * URI to access this asset externally to Immutable X
     * @type {string}
     * @memberof AssetWithOrders
     */
    'uri': string | null;
    /**
     * Ethereum address of the user who owns this asset
     * @type {string}
     * @memberof AssetWithOrders
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Balance
 */
interface Balance {
    /**
     * Amount which is currently inside the exchange
     * @type {string}
     * @memberof Balance
     */
    'balance': string;
    /**
     * Amount which is currently preparing withdrawal from the exchange
     * @type {string}
     * @memberof Balance
     */
    'preparing_withdrawal': string;
    /**
     * Symbol of the token (e.g. ETH, IMX)
     * @type {string}
     * @memberof Balance
     */
    'symbol': string;
    /**
     * Address of the contract that represents this ERC20 token or empty for ETH
     * @type {string}
     * @memberof Balance
     */
    'token_address': string;
    /**
     * Amount which is currently withdrawable from the exchange
     * @type {string}
     * @memberof Balance
     */
    'withdrawable': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CancelOrderRequest
 */
interface CancelOrderRequest {
    /**
     * ID of the order
     * @type {number}
     * @memberof CancelOrderRequest
     */
    'order_id': number;
    /**
     * Payload signature
     * @type {string}
     * @memberof CancelOrderRequest
     */
    'stark_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CancelOrderResponse
 */
interface CancelOrderResponse {
    /**
     * ID of the cancelled order
     * @type {number}
     * @memberof CancelOrderResponse
     */
    'order_id': number;
    /**
     * New status of the order
     * @type {string}
     * @memberof CancelOrderResponse
     */
    'status': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Collection
 */
interface Collection {
    /**
     * Ethereum address of the ERC721 contract
     * @type {string}
     * @memberof Collection
     */
    'address': string;
    /**
     * URL of the tile image for this collection
     * @type {string}
     * @memberof Collection
     */
    'collection_image_url': string | null;
    /**
     * Timestamp of when the collection was created
     * @type {string}
     * @memberof Collection
     */
    'created_at': string | null;
    /**
     * Description of the collection
     * @type {string}
     * @memberof Collection
     */
    'description': string | null;
    /**
     * URL of the icon for this collection
     * @type {string}
     * @memberof Collection
     */
    'icon_url': string | null;
    /**
     * URL of the metadata for this collection
     * @type {string}
     * @memberof Collection
     */
    'metadata_api_url': string | null;
    /**
     * Name of the collection
     * @type {string}
     * @memberof Collection
     */
    'name': string;
    /**
     * The collection\'s project ID
     * @type {number}
     * @memberof Collection
     */
    'project_id': number;
    /**
     * Project owner address
     * @type {string}
     * @memberof Collection
     */
    'project_owner_address': string;
    /**
     * Timestamp of when the collection was updated
     * @type {string}
     * @memberof Collection
     */
    'updated_at': string | null;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Range
 */
interface Range {
    /**
     * Maximum value
     * @type {number}
     * @memberof Range
     */
    'max'?: number;
    /**
     * Minimum value
     * @type {number}
     * @memberof Range
     */
    'min'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CollectionFilter
 */
interface CollectionFilter {
    /**
     * Key of this property
     * @type {string}
     * @memberof CollectionFilter
     */
    'key'?: string;
    /**
     *
     * @type {Range}
     * @memberof CollectionFilter
     */
    'range'?: Range;
    /**
     * Type of this filter
     * @type {string}
     * @memberof CollectionFilter
     */
    'type'?: string;
    /**
     * List of possible values for this property
     * @type {Array<string>}
     * @memberof CollectionFilter
     */
    'value'?: Array<string>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ContractCreateAPIRequest
 */
interface ContractCreateAPIRequest {
    /**
     *
     * @type {string}
     * @memberof ContractCreateAPIRequest
     */
    'contract_address'?: string;
    /**
     *
     * @type {string}
     * @memberof ContractCreateAPIRequest
     */
    'data_url'?: string;
    /**
     *
     * @type {string}
     * @memberof ContractCreateAPIRequest
     */
    'mint_url'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ContractCreateResponse
 */
interface ContractCreateResponse {
    /**
     *
     * @type {string}
     * @memberof ContractCreateResponse
     */
    'webhook_hash'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateCollectionRequest
 */
interface CreateCollectionRequest {
    /**
     * URL of the tile image for this collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'collection_image_url'?: string;
    /**
     * Ethereum address of the ERC721 contract
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'contract_address': string;
    /**
     * Description of the collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the icon for this collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'icon_url'?: string;
    /**
     * URL of the metadata for this collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'metadata_api_url'?: string;
    /**
     * Name of the collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'name': string;
    /**
     * Owner Public Key: The uncompressed public key of the owner of the contract
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'owner_public_key': string;
    /**
     * The collection\'s project ID
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    'project_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface WidgetParams
 */
interface WidgetParams {
    /**
     * Amount that will be prefilled in the widget
     * @type {string}
     * @memberof WidgetParams
     */
    'amount'?: string;
    /**
     * Currencies that will be available in the widget. If not defined all available currencies will be shown
     * @type {Array<string>}
     * @memberof WidgetParams
     */
    'supported_currencies'?: Array<string>;
    /**
     * Widget theme dark by default
     * @type {string}
     * @memberof WidgetParams
     */
    'theme'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CreateExchangeAndURLAPIRequest
 */
interface CreateExchangeAndURLAPIRequest {
    /**
     * Provider name
     * @type {string}
     * @memberof CreateExchangeAndURLAPIRequest
     */
    'provider'?: CreateExchangeAndURLAPIRequestProviderEnum;
    /**
     * Transaction type
     * @type {string}
     * @memberof CreateExchangeAndURLAPIRequest
     */
    'type'?: CreateExchangeAndURLAPIRequestTypeEnum;
    /**
     * Ethereum address of the user who wants to create transaction
     * @type {string}
     * @memberof CreateExchangeAndURLAPIRequest
     */
    'wallet_address'?: string;
    /**
     *
     * @type {WidgetParams}
     * @memberof CreateExchangeAndURLAPIRequest
     */
    'widget'?: WidgetParams;
}
declare const CreateExchangeAndURLAPIRequestProviderEnum: {
    readonly Moonpay: "moonpay";
    readonly Layerswap: "layerswap";
};
declare type CreateExchangeAndURLAPIRequestProviderEnum = typeof CreateExchangeAndURLAPIRequestProviderEnum[keyof typeof CreateExchangeAndURLAPIRequestProviderEnum];
declare const CreateExchangeAndURLAPIRequestTypeEnum: {
    readonly Onramp: "onramp";
    readonly Offramp: "offramp";
};
declare type CreateExchangeAndURLAPIRequestTypeEnum = typeof CreateExchangeAndURLAPIRequestTypeEnum[keyof typeof CreateExchangeAndURLAPIRequestTypeEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateMetadataRefreshRequest
 */
interface CreateMetadataRefreshRequest {
    /**
     * The collection contract address
     * @type {string}
     * @memberof CreateMetadataRefreshRequest
     */
    'collection_address': string;
    /**
     * The tokens to refresh
     * @type {Array<string>}
     * @memberof CreateMetadataRefreshRequest
     */
    'token_ids': Array<string>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateMetadataRefreshResponse
 */
interface CreateMetadataRefreshResponse {
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof CreateMetadataRefreshResponse
     */
    'refresh_id': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface FeeEntry
 */
interface FeeEntry {
    /**
     *
     * @type {string}
     * @memberof FeeEntry
     */
    'address'?: string;
    /**
     *
     * @type {number}
     * @memberof FeeEntry
     */
    'fee_percentage'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CreateOrderRequest
 */
interface CreateOrderRequest {
    /**
     * Amount to buy
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'asset_id_sell': string;
    /**
     * Expiration timestamp for this order
     * @type {number}
     * @memberof CreateOrderRequest
     */
    'expiration_timestamp': number;
    /**
     * Fee information
     * @type {Array<FeeEntry>}
     * @memberof CreateOrderRequest
     */
    'fees'?: Array<FeeEntry>;
    /**
     * Whether to include fees in order
     * @type {boolean}
     * @memberof CreateOrderRequest
     */
    'include_fees'?: boolean;
    /**
     * Nonce of the order
     * @type {number}
     * @memberof CreateOrderRequest
     */
    'nonce': number;
    /**
     * Public stark key of the user creating order
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'stark_signature': string;
    /**
     * ID of the vault into which the bought asset will be placed
     * @type {number}
     * @memberof CreateOrderRequest
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof CreateOrderRequest
     */
    'vault_id_sell': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateOrderResponse
 */
interface CreateOrderResponse {
    /**
     * ID of the created order
     * @type {number}
     * @memberof CreateOrderResponse
     */
    'order_id': number;
    /**
     * Request ID as a reference for an asynchronous order creation request
     * @type {string}
     * @memberof CreateOrderResponse
     */
    'request_id'?: string;
    /**
     * Status of the created order
     * @type {string}
     * @memberof CreateOrderResponse
     */
    'status': string;
    /**
     * Timestamp of the created order
     * @type {number}
     * @memberof CreateOrderResponse
     */
    'time': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateProjectRequest
 */
interface CreateProjectRequest {
    /**
     * The company name
     * @type {string}
     * @memberof CreateProjectRequest
     */
    'company_name': string;
    /**
     * The project contact email (must be registered as a developer account with Immutable at https://hub.immutable.com)
     * @type {string}
     * @memberof CreateProjectRequest
     */
    'contact_email': string;
    /**
     * The project name
     * @type {string}
     * @memberof CreateProjectRequest
     */
    'name': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateProjectResponse
 */
interface CreateProjectResponse {
    /**
     * The project ID
     * @type {number}
     * @memberof CreateProjectResponse
     */
    'id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface FeeInfo
 */
interface FeeInfo {
    /**
     * ID of the asset these fees relate to
     * @type {string}
     * @memberof FeeInfo
     */
    'asset_id': string;
    /**
     * Fee limit
     * @type {string}
     * @memberof FeeInfo
     */
    'fee_limit': string;
    /**
     * ID of vault the asset belong to
     * @type {number}
     * @memberof FeeInfo
     */
    'source_vault_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CreateTradeRequestV1
 */
interface CreateTradeRequestV1 {
    /**
     * Amount to buy
     * @type {string}
     * @memberof CreateTradeRequestV1
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof CreateTradeRequestV1
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof CreateTradeRequestV1
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof CreateTradeRequestV1
     */
    'asset_id_sell': string;
    /**
     * Expiration timestamp for this trade
     * @type {number}
     * @memberof CreateTradeRequestV1
     */
    'expiration_timestamp': number;
    /**
     *
     * @type {FeeInfo}
     * @memberof CreateTradeRequestV1
     */
    'fee_info'?: FeeInfo;
    /**
     * Fee information
     * @type {Array<FeeEntry>}
     * @memberof CreateTradeRequestV1
     */
    'fees'?: Array<FeeEntry>;
    /**
     * [deprecated] All orders include fees since the introduction of protocol fees
     * @type {boolean}
     * @memberof CreateTradeRequestV1
     */
    'include_fees'?: boolean;
    /**
     * Nonce of the trade
     * @type {number}
     * @memberof CreateTradeRequestV1
     */
    'nonce': number;
    /**
     * ID of the order
     * @type {number}
     * @memberof CreateTradeRequestV1
     */
    'order_id': number;
    /**
     * Public stark key of the user creating trade
     * @type {string}
     * @memberof CreateTradeRequestV1
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof CreateTradeRequestV1
     */
    'stark_signature': string;
    /**
     * ID of the vault into which the traded asset will be placed
     * @type {number}
     * @memberof CreateTradeRequestV1
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof CreateTradeRequestV1
     */
    'vault_id_sell': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTradeResponse
 */
interface CreateTradeResponse {
    /**
     * Request ID as a reference for an asynchronous trade creation request
     * @type {string}
     * @memberof CreateTradeResponse
     */
    'request_id'?: string;
    /**
     * Current status of trade
     * @type {string}
     * @memberof CreateTradeResponse
     */
    'status': string;
    /**
     * ID of trade within Immutable X
     * @type {number}
     * @memberof CreateTradeResponse
     */
    'trade_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface TransferRequest
 */
interface TransferRequest {
    /**
     * Amount to transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'amount': string;
    /**
     * ID of the asset to transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'asset_id': string;
    /**
     * Expiration timestamp for this transfer
     * @type {number}
     * @memberof TransferRequest
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof TransferRequest
     */
    'nonce': number;
    /**
     * Public stark key of the user receiving the transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault into which the asset will be transferred to
     * @type {number}
     * @memberof TransferRequest
     */
    'receiver_vault_id': number;
    /**
     * ID of the vault into which the asset is from
     * @type {number}
     * @memberof TransferRequest
     */
    'sender_vault_id': number;
    /**
     * Transfer payload signature
     * @type {string}
     * @memberof TransferRequest
     */
    'stark_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CreateTransferRequest
 */
interface CreateTransferRequest {
    /**
     * List of transfers
     * @type {Array<TransferRequest>}
     * @memberof CreateTransferRequest
     */
    'requests': Array<TransferRequest>;
    /**
     * Public stark key of the user sending the transfer
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'sender_stark_key': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTransferRequestV1
 */
interface CreateTransferRequestV1 {
    /**
     * Amount to transfer
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'amount': string;
    /**
     * ID of the asset to transfer
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'asset_id': string;
    /**
     * Expiration timestamp for this transfer
     * @type {number}
     * @memberof CreateTransferRequestV1
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof CreateTransferRequestV1
     */
    'nonce': number;
    /**
     * Public stark key of the user receiving the transfer
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault into which the asset will be transferred to
     * @type {number}
     * @memberof CreateTransferRequestV1
     */
    'receiver_vault_id': number;
    /**
     * Public stark key of the user sending the transfer
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'sender_stark_key': string;
    /**
     * ID of the vault into which the asset is from
     * @type {number}
     * @memberof CreateTransferRequestV1
     */
    'sender_vault_id': number;
    /**
     * Transfer payload signature
     * @type {string}
     * @memberof CreateTransferRequestV1
     */
    'stark_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTransferResponse
 */
interface CreateTransferResponse {
    /**
     * List of transfer IDs
     * @type {Array<number>}
     * @memberof CreateTransferResponse
     */
    'transfer_ids': Array<number>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTransferResponseV1
 */
interface CreateTransferResponseV1 {
    /**
     * [deprecated] Sent signature
     * @type {string}
     * @memberof CreateTransferResponseV1
     */
    'sent_signature': string;
    /**
     * [deprecated] The status of transfer
     * @type {string}
     * @memberof CreateTransferResponseV1
     */
    'status': string;
    /**
     * [deprecated] Time of the transfer
     * @type {number}
     * @memberof CreateTransferResponseV1
     */
    'time': number;
    /**
     * ID of the transfer
     * @type {number}
     * @memberof CreateTransferResponseV1
     */
    'transfer_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateWithdrawalRequest
 */
interface CreateWithdrawalRequest {
    /**
     * Amount to withdraw
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    'amount': string;
    /**
     * The ID of asset the user is withdrawing
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    'asset_id': string;
    /**
     * Nonce of the withdrawal
     * @type {number}
     * @memberof CreateWithdrawalRequest
     */
    'nonce': number;
    /**
     * Public stark key of the withdrawing user
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    'stark_signature': string;
    /**
     * The ID of the vault the asset belong to
     * @type {number}
     * @memberof CreateWithdrawalRequest
     */
    'vault_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateWithdrawalResponse
 */
interface CreateWithdrawalResponse {
    /**
     * Status of the withdrawal
     * @type {string}
     * @memberof CreateWithdrawalResponse
     */
    'status': string;
    /**
     * Time of the withdrawal
     * @type {number}
     * @memberof CreateWithdrawalResponse
     */
    'time': number;
    /**
     * ID of the withdrawal
     * @type {number}
     * @memberof CreateWithdrawalResponse
     */
    'withdrawal_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CurrencyWithLimits
 */
interface CurrencyWithLimits {
    /**
     * Provider currency code
     * @type {string}
     * @memberof CurrencyWithLimits
     */
    'currency_code'?: string;
    /**
     *
     * @type {AggregateLimit}
     * @memberof CurrencyWithLimits
     */
    'limits'?: AggregateLimit;
    /**
     * Provider name (e.g. moonpay)
     * @type {string}
     * @memberof CurrencyWithLimits
     */
    'provider'?: string;
    /**
     * Currency Symbol
     * @type {string}
     * @memberof CurrencyWithLimits
     */
    'symbol'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface TokenData
 */
interface TokenData {
    /**
     * Number of decimals supported by this asset
     * @type {number}
     * @memberof TokenData
     */
    'decimals'?: number;
    /**
     * [DEPRECATED] Internal Immutable X Token ID
     * @type {string}
     * @memberof TokenData
     */
    'id'?: string;
    /**
     *
     * @type {AssetProperties}
     * @memberof TokenData
     */
    'properties'?: AssetProperties;
    /**
     * Quantity of this asset - inclusive of fees for buy order in v1 API and exclusive of fees in v3 API
     * @type {string}
     * @memberof TokenData
     */
    'quantity': string;
    /**
     * Quantity of this asset with the sum of all fees applied to the asset
     * @type {string}
     * @memberof TokenData
     */
    'quantity_with_fees': string;
    /**
     * Symbol of a token
     * @type {string}
     * @memberof TokenData
     */
    'symbol'?: string;
    /**
     * Address of ERC721/ERC20 contract
     * @type {string}
     * @memberof TokenData
     */
    'token_address'?: string;
    /**
     * ERC721 Token ID
     * @type {string}
     * @memberof TokenData
     */
    'token_id'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Token
 */
interface Token {
    /**
     *
     * @type {TokenData}
     * @memberof Token
     */
    'data': TokenData;
    /**
     * Type of this asset (ETH/ERC20/ERC721)
     * @type {string}
     * @memberof Token
     */
    'type': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Deposit
 */
interface Deposit {
    /**
     * Status of this deposit in Immutable X
     * @type {string}
     * @memberof Deposit
     */
    'status': string;
    /**
     * Timestamp of the deposit
     * @type {string}
     * @memberof Deposit
     */
    'timestamp': string;
    /**
     *
     * @type {Token}
     * @memberof Deposit
     */
    'token': Token;
    /**
     * Sequential ID of this transaction within Immutable X
     * @type {number}
     * @memberof Deposit
     */
    'transaction_id': number;
    /**
     * Ethereum address of the user making this deposit
     * @type {string}
     * @memberof Deposit
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface EncodeAssetTokenData
 */
interface EncodeAssetTokenData {
    /**
     * Blueprint information of the token to be encoded. Used if token is mintable.
     * @type {string}
     * @memberof EncodeAssetTokenData
     */
    'blueprint'?: string;
    /**
     * ID of the token to be encoded. Used if token is mintable.
     * @type {string}
     * @memberof EncodeAssetTokenData
     */
    'id'?: string;
    /**
     * Contract address of the token to be encoded
     * @type {string}
     * @memberof EncodeAssetTokenData
     */
    'token_address'?: string;
    /**
     * TokenId of the token to be encoded. Used if token is non-mintable
     * @type {string}
     * @memberof EncodeAssetTokenData
     */
    'token_id'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface EncodeAssetRequestToken
 */
interface EncodeAssetRequestToken {
    /**
     *
     * @type {EncodeAssetTokenData}
     * @memberof EncodeAssetRequestToken
     */
    'data'?: EncodeAssetTokenData;
    /**
     * The type of the token to be encoded
     * @type {string}
     * @memberof EncodeAssetRequestToken
     */
    'type'?: EncodeAssetRequestTokenTypeEnum;
}
declare const EncodeAssetRequestTokenTypeEnum: {
    readonly Eth: "ETH";
    readonly Erc20: "ERC20";
    readonly Erc721: "ERC721";
};
declare type EncodeAssetRequestTokenTypeEnum = typeof EncodeAssetRequestTokenTypeEnum[keyof typeof EncodeAssetRequestTokenTypeEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface EncodeAssetRequest
 */
interface EncodeAssetRequest {
    /**
     *
     * @type {EncodeAssetRequestToken}
     * @memberof EncodeAssetRequest
     */
    'token': EncodeAssetRequestToken;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface EncodeAssetResponse
 */
interface EncodeAssetResponse {
    /**
     * Stark encoded asset id
     * @type {string}
     * @memberof EncodeAssetResponse
     */
    'asset_id': string;
    /**
     * Stark encoded asset type
     * @type {string}
     * @memberof EncodeAssetResponse
     */
    'asset_type': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface OptionalExchangeData
 */
interface OptionalExchangeData {
    /**
     * Provider transaction ID
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'external_id'?: string;
    /**
     * Fees amount
     * @type {number}
     * @memberof OptionalExchangeData
     */
    'fees_amount'?: number;
    /**
     * Amount that was exchanged from
     * @type {number}
     * @memberof OptionalExchangeData
     */
    'from_amount'?: number;
    /**
     * Currency that was exchanged from
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'from_currency'?: string;
    /**
     * Provider wallet address that was used for transferring crypto
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'provider_wallet_address'?: string;
    /**
     * Amount that was exchanged to
     * @type {number}
     * @memberof OptionalExchangeData
     */
    'to_amount'?: number;
    /**
     * Currency that was exchanged to
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'to_currency'?: string;
    /**
     * Transfer ID
     * @type {string}
     * @memberof OptionalExchangeData
     */
    'transfer_id'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Exchange
 */
interface Exchange {
    /**
     * Time this transaction was created
     * @type {string}
     * @memberof Exchange
     */
    'created_at'?: string;
    /**
     *
     * @type {OptionalExchangeData}
     * @memberof Exchange
     */
    'data'?: OptionalExchangeData;
    /**
     * Transaction ID
     * @type {number}
     * @memberof Exchange
     */
    'id'?: number;
    /**
     * Provider name
     * @type {string}
     * @memberof Exchange
     */
    'provider'?: string;
    /**
     * Transaction status
     * @type {string}
     * @memberof Exchange
     */
    'status'?: string;
    /**
     * Transaction type
     * @type {string}
     * @memberof Exchange
     */
    'type'?: string;
    /**
     * Time this transaction was updates
     * @type {string}
     * @memberof Exchange
     */
    'updated_at'?: string;
    /**
     * Ethereum address of the user who created transaction
     * @type {string}
     * @memberof Exchange
     */
    'wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ExchangeCreateExchangeAndURLResponse
 */
interface ExchangeCreateExchangeAndURLResponse {
    /**
     * Created transaction ID
     * @type {number}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'id'?: number;
    /**
     * Provider name (e.g. moonpay)
     * @type {string}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'provider'?: string;
    /**
     * Transaction type
     * @type {string}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'type'?: string;
    /**
     * Widget URL
     * @type {string}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'url'?: string;
    /**
     * Ethereum address of the user who created transaction
     * @type {string}
     * @memberof ExchangeCreateExchangeAndURLResponse
     */
    'wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface FeeData
 */
interface FeeData {
    /**
     * Address of ERC721/ERC20 contract
     * @type {string}
     * @memberof FeeData
     */
    'contract_address'?: string;
    /**
     * Number of decimals supported by this asset
     * @type {number}
     * @memberof FeeData
     */
    'decimals'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface FeeToken
 */
interface FeeToken {
    /**
     *
     * @type {FeeData}
     * @memberof FeeToken
     */
    'data'?: FeeData;
    /**
     * Fee token type. One of ETH/ERC20
     * @type {string}
     * @memberof FeeToken
     */
    'type'?: FeeTokenTypeEnum;
}
declare const FeeTokenTypeEnum: {
    readonly Eth: "ETH";
    readonly Erc20: "ERC20";
};
declare type FeeTokenTypeEnum = typeof FeeTokenTypeEnum[keyof typeof FeeTokenTypeEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataRefreshErrors
 */
interface MetadataRefreshErrors {
    /**
     * Metadata API response for the token
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'client_response_body': string | null;
    /**
     * Metadata API response code for the token
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'client_response_status_code': string | null;
    /**
     * Requested metadata url for the token
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'client_token_metadata_url': string;
    /**
     * The collection contract address
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'collection_address': string;
    /**
     * When the error was created
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'created_at': string;
    /**
     * Metadata refresh error code
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'error_code': string;
    /**
     * The token ID
     * @type {string}
     * @memberof MetadataRefreshErrors
     */
    'token_id': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetMetadataRefreshErrorsResponse
 */
interface GetMetadataRefreshErrorsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof GetMetadataRefreshErrorsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof GetMetadataRefreshErrorsResponse
     */
    'remaining': number;
    /**
     * Metadata refresh errors matching query parameters
     * @type {Array<MetadataRefreshErrors>}
     * @memberof GetMetadataRefreshErrorsResponse
     */
    'result': Array<MetadataRefreshErrors>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataRefreshSummary
 */
interface MetadataRefreshSummary {
    /**
     * The number of tokens with failed metadata refreshes
     * @type {number}
     * @memberof MetadataRefreshSummary
     */
    'failed'?: number;
    /**
     * The number of tokens that has not been refreshed yet
     * @type {number}
     * @memberof MetadataRefreshSummary
     */
    'pending'?: number;
    /**
     * The number of tokens with successful metadata refreshes
     * @type {number}
     * @memberof MetadataRefreshSummary
     */
    'succeeded'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetMetadataRefreshResponse
 */
interface GetMetadataRefreshResponse {
    /**
     * The collection address
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'collection_address': string;
    /**
     * When the metadata refresh completed
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'completed_at'?: string | null;
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'refresh_id': string;
    /**
     * When the metadata refresh started
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'started_at': string;
    /**
     * The metadata refresh status
     * @type {string}
     * @memberof GetMetadataRefreshResponse
     */
    'status': GetMetadataRefreshResponseStatusEnum;
    /**
     * The current metadata refresh summary. The summary continue to update until metadata refresh is completed
     * @type {Array<MetadataRefreshSummary>}
     * @memberof GetMetadataRefreshResponse
     */
    'summary': Array<MetadataRefreshSummary>;
}
declare const GetMetadataRefreshResponseStatusEnum: {
    readonly Queued: "queued";
    readonly InProgress: "in_progress";
    readonly Completed: "completed";
};
declare type GetMetadataRefreshResponseStatusEnum = typeof GetMetadataRefreshResponseStatusEnum[keyof typeof GetMetadataRefreshResponseStatusEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataRefreshExcludingSummary
 */
interface MetadataRefreshExcludingSummary {
    /**
     * The collection address
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'collection_address': string;
    /**
     * When the metadata refresh completed
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'completed_at'?: string | null;
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'refresh_id': string;
    /**
     * When the metadata refresh started
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'started_at': string;
    /**
     * The metadata refresh status
     * @type {string}
     * @memberof MetadataRefreshExcludingSummary
     */
    'status': MetadataRefreshExcludingSummaryStatusEnum;
}
declare const MetadataRefreshExcludingSummaryStatusEnum: {
    readonly Queued: "queued";
    readonly InProgress: "in_progress";
    readonly Completed: "completed";
};
declare type MetadataRefreshExcludingSummaryStatusEnum = typeof MetadataRefreshExcludingSummaryStatusEnum[keyof typeof MetadataRefreshExcludingSummaryStatusEnum];

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetMetadataRefreshes
 */
interface GetMetadataRefreshes {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof GetMetadataRefreshes
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof GetMetadataRefreshes
     */
    'remaining': number;
    /**
     * Metadata refresh errors matching query parameters
     * @type {Array<MetadataRefreshExcludingSummary>}
     * @memberof GetMetadataRefreshes
     */
    'result': Array<MetadataRefreshExcludingSummary>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Project
 */
interface Project {
    /**
     * The current period expiry date for collection limit
     * @type {string}
     * @memberof Project
     */
    'collection_limit_expires_at': string;
    /**
     * The total monthly collection limit
     * @type {number}
     * @memberof Project
     */
    'collection_monthly_limit': number;
    /**
     * The number of collection remaining in the current period
     * @type {number}
     * @memberof Project
     */
    'collection_remaining': number;
    /**
     * The company name
     * @type {string}
     * @memberof Project
     */
    'company_name': string;
    /**
     * The project contact email (must be registered as a developer account with Immutable at https://hub.immutable.com)
     * @type {string}
     * @memberof Project
     */
    'contact_email': string;
    /**
     * The project ID
     * @type {number}
     * @memberof Project
     */
    'id': number;
    /**
     * The current period expiry date for mint operation limit
     * @type {string}
     * @memberof Project
     */
    'mint_limit_expires_at': string;
    /**
     * The total monthly mint operation limit
     * @type {number}
     * @memberof Project
     */
    'mint_monthly_limit': number;
    /**
     * The number of mint operation remaining in the current period
     * @type {number}
     * @memberof Project
     */
    'mint_remaining': number;
    /**
     * The project name
     * @type {string}
     * @memberof Project
     */
    'name': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetProjectsResponse
 */
interface GetProjectsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof GetProjectsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof GetProjectsResponse
     */
    'remaining': number;
    /**
     * Projects matching query parameters
     * @type {Array<Project>}
     * @memberof GetProjectsResponse
     */
    'result': Array<Project>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableCancelOrderRequest
 */
interface GetSignableCancelOrderRequest {
    /**
     * ID of the order to be cancelled
     * @type {number}
     * @memberof GetSignableCancelOrderRequest
     */
    'order_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableCancelOrderResponse
 */
interface GetSignableCancelOrderResponse {
    /**
     * ID of the order to be cancelled
     * @type {number}
     * @memberof GetSignableCancelOrderResponse
     */
    'order_id': number;
    /**
     * Hash of the payload to be signed for cancel order
     * @type {string}
     * @memberof GetSignableCancelOrderResponse
     */
    'payload_hash': string;
    /**
     * Message to sign from wallet to confirm cancel order
     * @type {string}
     * @memberof GetSignableCancelOrderResponse
     */
    'signable_message': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface SignableToken
 */
interface SignableToken {
    /**
     * Token data. See https://docs.x.immutable.com/docs/token-data-object
     * @type {object}
     * @memberof SignableToken
     */
    'data'?: object;
    /**
     * Type of token
     * @type {string}
     * @memberof SignableToken
     */
    'type'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableDepositRequest
 */
interface GetSignableDepositRequest {
    /**
     * Amount of the token the user is depositing
     * @type {string}
     * @memberof GetSignableDepositRequest
     */
    'amount': string;
    /**
     *
     * @type {SignableToken}
     * @memberof GetSignableDepositRequest
     */
    'token': SignableToken;
    /**
     * User who is depositing
     * @type {string}
     * @memberof GetSignableDepositRequest
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableDepositResponse
 */
interface GetSignableDepositResponse {
    /**
     * Amount this user is depositing
     * @type {string}
     * @memberof GetSignableDepositResponse
     */
    'amount': string;
    /**
     * ID of the asset this user is depositing
     * @type {string}
     * @memberof GetSignableDepositResponse
     */
    'asset_id': string;
    /**
     * Nonce of the deposit
     * @type {number}
     * @memberof GetSignableDepositResponse
     */
    'nonce': number;
    /**
     * Public stark key of the depositing user
     * @type {string}
     * @memberof GetSignableDepositResponse
     */
    'stark_key': string;
    /**
     * ID of the vault this user is depositing to
     * @type {number}
     * @memberof GetSignableDepositResponse
     */
    'vault_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableOrderRequest
 */
interface GetSignableOrderRequest {
    /**
     * Fee-exclusive amount to buy the asset
     * @type {string}
     * @memberof GetSignableOrderRequest
     */
    'amount_buy': string;
    /**
     * Amount to sell (quantity)
     * @type {string}
     * @memberof GetSignableOrderRequest
     */
    'amount_sell': string;
    /**
     * ExpirationTimestamp in Unix time. Note: will be rounded down to the nearest hour
     * @type {number}
     * @memberof GetSignableOrderRequest
     */
    'expiration_timestamp'?: number;
    /**
     * Inclusion of either maker or taker fees
     * @type {Array<FeeEntry>}
     * @memberof GetSignableOrderRequest
     */
    'fees'?: Array<FeeEntry>;
    /**
     *
     * @type {SignableToken}
     * @memberof GetSignableOrderRequest
     */
    'token_buy': SignableToken;
    /**
     *
     * @type {SignableToken}
     * @memberof GetSignableOrderRequest
     */
    'token_sell': SignableToken;
    /**
     * Ethereum address of the submitting user
     * @type {string}
     * @memberof GetSignableOrderRequest
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableOrderResponse
 */
interface GetSignableOrderResponse {
    /**
     * Fee-exclusive amount to buy
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'asset_id_sell': string;
    /**
     * Expiration timestamp for this order
     * @type {number}
     * @memberof GetSignableOrderResponse
     */
    'expiration_timestamp': number;
    /**
     *
     * @type {FeeInfo}
     * @memberof GetSignableOrderResponse
     */
    'fee_info'?: FeeInfo;
    /**
     * Nonce of the order
     * @type {number}
     * @memberof GetSignableOrderResponse
     */
    'nonce': number;
    /**
     * Hash of the payload to be signed for signable order
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'payload_hash': string;
    /**
     * Message to sign with L1 wallet to confirm order request
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'signable_message': string;
    /**
     * Public stark key of the created user
     * @type {string}
     * @memberof GetSignableOrderResponse
     */
    'stark_key': string;
    /**
     * ID of the vault into which the bought asset will be placed
     * @type {number}
     * @memberof GetSignableOrderResponse
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof GetSignableOrderResponse
     */
    'vault_id_sell': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableRegistrationOffchainResponse
 */
interface GetSignableRegistrationOffchainResponse {
    /**
     * Hash of the payload to be signed for user registration offchain
     * @type {string}
     * @memberof GetSignableRegistrationOffchainResponse
     */
    'payload_hash': string;
    /**
     * Message to sign with L1 wallet to register user offchain
     * @type {string}
     * @memberof GetSignableRegistrationOffchainResponse
     */
    'signable_message': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableRegistrationRequest
 */
interface GetSignableRegistrationRequest {
    /**
     * Ether key of user
     * @type {string}
     * @memberof GetSignableRegistrationRequest
     */
    'ether_key': string;
    /**
     * Public stark key of the user
     * @type {string}
     * @memberof GetSignableRegistrationRequest
     */
    'stark_key': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableRegistrationResponse
 */
interface GetSignableRegistrationResponse {
    /**
     * Signature from authorised operator
     * @type {string}
     * @memberof GetSignableRegistrationResponse
     */
    'operator_signature': string;
    /**
     * Hash of the payload to be signed for user registration
     * @type {string}
     * @memberof GetSignableRegistrationResponse
     */
    'payload_hash': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTradeRequest
 */
interface GetSignableTradeRequest {
    /**
     * ExpirationTimestamp in Unix time. Note: will be rounded down to the nearest hour
     * @type {number}
     * @memberof GetSignableTradeRequest
     */
    'expiration_timestamp'?: number;
    /**
     * Inclusion of either maker or taker fees
     * @type {Array<FeeEntry>}
     * @memberof GetSignableTradeRequest
     */
    'fees'?: Array<FeeEntry>;
    /**
     * The ID of the maker order involved
     * @type {number}
     * @memberof GetSignableTradeRequest
     */
    'order_id': number;
    /**
     * Ethereum address of the submitting user
     * @type {string}
     * @memberof GetSignableTradeRequest
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTradeResponse
 */
interface GetSignableTradeResponse {
    /**
     * Amount to buy
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'amount_buy': string;
    /**
     * Amount to sell
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'amount_sell': string;
    /**
     * ID of the asset to buy
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'asset_id_buy': string;
    /**
     * ID of the asset to sell
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'asset_id_sell': string;
    /**
     * Expiration timestamp for this order
     * @type {number}
     * @memberof GetSignableTradeResponse
     */
    'expiration_timestamp': number;
    /**
     *
     * @type {FeeInfo}
     * @memberof GetSignableTradeResponse
     */
    'fee_info'?: FeeInfo;
    /**
     * Nonce of the order
     * @type {number}
     * @memberof GetSignableTradeResponse
     */
    'nonce': number;
    /**
     * Payload Hash
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'payload_hash': string;
    /**
     * Message to sign with L1 wallet to confirm trade request
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'signable_message': string;
    /**
     * Public stark key of the created user
     * @type {string}
     * @memberof GetSignableTradeResponse
     */
    'stark_key': string;
    /**
     * ID of the vault into which the bought asset will be placed
     * @type {number}
     * @memberof GetSignableTradeResponse
     */
    'vault_id_buy': number;
    /**
     * ID of the vault to sell from
     * @type {number}
     * @memberof GetSignableTradeResponse
     */
    'vault_id_sell': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface SignableTransferDetails
 */
interface SignableTransferDetails {
    /**
     * Amount of the token to transfer
     * @type {string}
     * @memberof SignableTransferDetails
     */
    'amount': string;
    /**
     * Ethereum address of the receiving user
     * @type {string}
     * @memberof SignableTransferDetails
     */
    'receiver': string;
    /**
     *
     * @type {SignableToken}
     * @memberof SignableTransferDetails
     */
    'token': SignableToken;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTransferRequest
 */
interface GetSignableTransferRequest {
    /**
     * Ethereum address of the transferring user
     * @type {string}
     * @memberof GetSignableTransferRequest
     */
    'sender_ether_key': string;
    /**
     * List of signable transfer details
     * @type {Array<SignableTransferDetails>}
     * @memberof GetSignableTransferRequest
     */
    'signable_requests': Array<SignableTransferDetails>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTransferRequestV1
 */
interface GetSignableTransferRequestV1 {
    /**
     * Amount of the token to transfer
     * @type {string}
     * @memberof GetSignableTransferRequestV1
     */
    'amount': string;
    /**
     * Ethereum address of the receiving user
     * @type {string}
     * @memberof GetSignableTransferRequestV1
     */
    'receiver': string;
    /**
     * Ethereum address of the transferring user
     * @type {string}
     * @memberof GetSignableTransferRequestV1
     */
    'sender': string;
    /**
     *
     * @type {SignableToken}
     * @memberof GetSignableTransferRequestV1
     */
    'token': SignableToken;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface SignableTransferResponseDetails
 */
interface SignableTransferResponseDetails {
    /**
     * Amount of the asset being transferred
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'amount': string;
    /**
     * ID of the asset being transferred
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'asset_id': string;
    /**
     * Timestamp when this transfer will expire
     * @type {number}
     * @memberof SignableTransferResponseDetails
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof SignableTransferResponseDetails
     */
    'nonce': number;
    /**
     * Hash of the payload to be signed for transfer
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'payload_hash': string;
    /**
     * Receiver of the transfer
     * @type {string}
     * @memberof SignableTransferResponseDetails
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault being transferred to
     * @type {number}
     * @memberof SignableTransferResponseDetails
     */
    'receiver_vault_id': number;
    /**
     * ID of the vault being transferred from
     * @type {number}
     * @memberof SignableTransferResponseDetails
     */
    'sender_vault_id': number;
    /**
     *
     * @type {SignableToken}
     * @memberof SignableTransferResponseDetails
     */
    'token': SignableToken;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTransferResponse
 */
interface GetSignableTransferResponse {
    /**
     * Sender of the transfer
     * @type {string}
     * @memberof GetSignableTransferResponse
     */
    'sender_stark_key': string;
    /**
     * Message to sign with L1 wallet to confirm transfer request
     * @type {string}
     * @memberof GetSignableTransferResponse
     */
    'signable_message': string;
    /**
     * List of transfer responses without the sender stark key
     * @type {Array<SignableTransferResponseDetails>}
     * @memberof GetSignableTransferResponse
     */
    'signable_responses': Array<SignableTransferResponseDetails>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableTransferResponseV1
 */
interface GetSignableTransferResponseV1 {
    /**
     * Amount of the asset being transferred
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'amount': string;
    /**
     * ID of the asset being transferred
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'asset_id': string;
    /**
     * Token in request to match in SDK implementation
     * @type {number}
     * @memberof GetSignableTransferResponseV1
     */
    'expiration_timestamp': number;
    /**
     * Nonce of the transfer
     * @type {number}
     * @memberof GetSignableTransferResponseV1
     */
    'nonce': number;
    /**
     * Hash of the payload
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'payload_hash': string;
    /**
     * Receiver of the transfer
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'receiver_stark_key': string;
    /**
     * ID of the vault being transferred to
     * @type {number}
     * @memberof GetSignableTransferResponseV1
     */
    'receiver_vault_id': number;
    /**
     * Sender of the transfer
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'sender_stark_key'?: string;
    /**
     * ID of the vault being transferred from
     * @type {number}
     * @memberof GetSignableTransferResponseV1
     */
    'sender_vault_id': number;
    /**
     * Message to sign with L1 wallet to confirm transfer request
     * @type {string}
     * @memberof GetSignableTransferResponseV1
     */
    'signable_message': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableWithdrawalRequest
 */
interface GetSignableWithdrawalRequest {
    /**
     * Amount of the token to withdraw
     * @type {string}
     * @memberof GetSignableWithdrawalRequest
     */
    'amount': string;
    /**
     *
     * @type {SignableToken}
     * @memberof GetSignableWithdrawalRequest
     */
    'token': SignableToken;
    /**
     * Ethereum address of the user who is making this withdrawal
     * @type {string}
     * @memberof GetSignableWithdrawalRequest
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableWithdrawalResponse
 */
interface GetSignableWithdrawalResponse {
    /**
     * Amount of the token we are withdrawing
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'amount': string;
    /**
     * ID of the asset to be withdrawn
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'asset_id': string;
    /**
     * Nonce of this transaction
     * @type {number}
     * @memberof GetSignableWithdrawalResponse
     */
    'nonce': number;
    /**
     * Encoded payload hash
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'payload_hash': string;
    /**
     * Message to sign with L1 wallet to verity withdrawal request
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'signable_message': string;
    /**
     * Public stark key of this user
     * @type {string}
     * @memberof GetSignableWithdrawalResponse
     */
    'stark_key': string;
    /**
     * ID of the vault we are withdrawing from
     * @type {number}
     * @memberof GetSignableWithdrawalResponse
     */
    'vault_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetTransactionsResponse
 */
interface GetTransactionsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof GetTransactionsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof GetTransactionsResponse
     */
    'remaining'?: number;
    /**
     * Transactions matching query parameters
     * @type {Array<Exchange>}
     * @memberof GetTransactionsResponse
     */
    'result'?: Array<Exchange>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetUsersApiResponse
 */
interface GetUsersApiResponse {
    /**
     * Accounts
     * @type {Array<string>}
     * @memberof GetUsersApiResponse
     */
    'accounts': Array<string>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface LambdasAPIError
 */
interface LambdasAPIError {
    /**
     * The error code
     * @type {string}
     * @memberof LambdasAPIError
     */
    'code'?: string;
    /**
     * The error details
     * @type {string}
     * @memberof LambdasAPIError
     */
    'details'?: string;
    /**
     * The error message
     * @type {string}
     * @memberof LambdasAPIError
     */
    'message'?: string;
    /**
     * The error status code
     * @type {number}
     * @memberof LambdasAPIError
     */
    'status_code'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListAssetsResponse
 */
interface ListAssetsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListAssetsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListAssetsResponse
     */
    'remaining': number;
    /**
     * Assets matching query parameters
     * @type {Array<AssetWithOrders>}
     * @memberof ListAssetsResponse
     */
    'result': Array<AssetWithOrders>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListBalancesResponse
 */
interface ListBalancesResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListBalancesResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListBalancesResponse
     */
    'remaining': number;
    /**
     * Dictionary of tokens
     * @type {Array<Balance>}
     * @memberof ListBalancesResponse
     */
    'result': Array<Balance>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListCollectionsResponse
 */
interface ListCollectionsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListCollectionsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListCollectionsResponse
     */
    'remaining': number;
    /**
     * Collections matching query parameters
     * @type {Array<Collection>}
     * @memberof ListCollectionsResponse
     */
    'result': Array<Collection>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListDepositsResponse
 */
interface ListDepositsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListDepositsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListDepositsResponse
     */
    'remaining': number;
    /**
     * Deposits matching query parameters
     * @type {Array<Deposit>}
     * @memberof ListDepositsResponse
     */
    'result': Array<Deposit>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Mint
 */
interface Mint {
    /**
     * Fee details
     * @type {Array<Fee>}
     * @memberof Mint
     */
    'fees'?: Array<Fee>;
    /**
     * Status of this mint
     * @type {string}
     * @memberof Mint
     */
    'status': string;
    /**
     * Timestamp this mint was initiated
     * @type {string}
     * @memberof Mint
     */
    'timestamp': string;
    /**
     *
     * @type {Token}
     * @memberof Mint
     */
    'token': Token;
    /**
     * Sequential ID of transaction in Immutable X
     * @type {number}
     * @memberof Mint
     */
    'transaction_id': number;
    /**
     * Ethereum address of the user to whom the asset has been minted
     * @type {string}
     * @memberof Mint
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListMintsResponse
 */
interface ListMintsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListMintsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListMintsResponse
     */
    'remaining': number;
    /**
     * Mints matching query parameters
     * @type {Array<Mint>}
     * @memberof ListMintsResponse
     */
    'result': Array<Mint>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface OrderFeeInfo
 */
interface OrderFeeInfo {
    /**
     * Address of the fee recipient
     * @type {string}
     * @memberof OrderFeeInfo
     */
    'address'?: string;
    /**
     * Fee amount
     * @type {string}
     * @memberof OrderFeeInfo
     */
    'amount'?: string;
    /**
     *
     * @type {FeeToken}
     * @memberof OrderFeeInfo
     */
    'token'?: FeeToken;
    /**
     * Fee type
     * @type {string}
     * @memberof OrderFeeInfo
     */
    'type'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Order
 */
interface Order {
    /**
     * Amount of the asset already sold by this order
     * @type {string}
     * @memberof Order
     */
    'amount_sold': string | null;
    /**
     *
     * @type {Token}
     * @memberof Order
     */
    'buy': Token;
    /**
     * Expiration timestamp of this order
     * @type {string}
     * @memberof Order
     */
    'expiration_timestamp': string | null;
    /**
     * Fee information for the order
     * @type {Array<OrderFeeInfo>}
     * @memberof Order
     */
    'fees'?: Array<OrderFeeInfo>;
    /**
     * ID of the order
     * @type {number}
     * @memberof Order
     */
    'order_id': number;
    /**
     *
     * @type {Token}
     * @memberof Order
     */
    'sell': Token;
    /**
     * Status of the order
     * @type {string}
     * @memberof Order
     */
    'status': string;
    /**
     * Timestamp this order was created
     * @type {string}
     * @memberof Order
     */
    'timestamp': string | null;
    /**
     * Updated timestamp of this order
     * @type {string}
     * @memberof Order
     */
    'updated_timestamp': string | null;
    /**
     * Ethereum address of the user who submitted the order
     * @type {string}
     * @memberof Order
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListOrdersResponse
 */
interface ListOrdersResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListOrdersResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListOrdersResponse
     */
    'remaining': number;
    /**
     * Orders matching query parameters
     * @type {Array<Order>}
     * @memberof ListOrdersResponse
     */
    'result': Array<Order>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface TokenDetails
 */
interface TokenDetails {
    /**
     * Number of decimals for token
     * @type {string}
     * @memberof TokenDetails
     */
    'decimals': string;
    /**
     * Url for the icon of the token
     * @type {string}
     * @memberof TokenDetails
     */
    'image_url': string;
    /**
     * Full name of the token (e.g. Ether)
     * @type {string}
     * @memberof TokenDetails
     */
    'name': string;
    /**
     * Quantum for token
     * @type {string}
     * @memberof TokenDetails
     */
    'quantum': string;
    /**
     * Ticker symbol for token (e.g. ETH/USDC/IMX)
     * @type {string}
     * @memberof TokenDetails
     */
    'symbol': string;
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof TokenDetails
     */
    'token_address': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListTokensResponse
 */
interface ListTokensResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListTokensResponse
     */
    'cursor': string;
    /**
     * Tokens matching query parameters
     * @type {Array<TokenDetails>}
     * @memberof ListTokensResponse
     */
    'result': Array<TokenDetails>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface TradeSide
 */
interface TradeSide {
    /**
     * The ID of the order involved in the trade
     * @type {number}
     * @memberof TradeSide
     */
    'order_id': number;
    /**
     * The amount of that order\'s asset this trade sold
     * @type {string}
     * @memberof TradeSide
     */
    'sold': string;
    /**
     * The contract address of the token that this trade sold
     * @type {string}
     * @memberof TradeSide
     */
    'token_address'?: string;
    /**
     * The ID of the token that this trade sold
     * @type {string}
     * @memberof TradeSide
     */
    'token_id'?: string;
    /**
     * The type of the token that this trade sold
     * @type {string}
     * @memberof TradeSide
     */
    'token_type': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Trade
 */
interface Trade {
    /**
     *
     * @type {TradeSide}
     * @memberof Trade
     */
    'a': TradeSide;
    /**
     *
     * @type {TradeSide}
     * @memberof Trade
     */
    'b': TradeSide;
    /**
     * Status of this trade
     * @type {string}
     * @memberof Trade
     */
    'status': string;
    /**
     * Time this trade occurred
     * @type {string}
     * @memberof Trade
     */
    'timestamp': string | null;
    /**
     * Sequential ID of this trade within Immutable X
     * @type {number}
     * @memberof Trade
     */
    'transaction_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListTradesResponse
 */
interface ListTradesResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListTradesResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListTradesResponse
     */
    'remaining': number;
    /**
     * Trades matching query parameters
     * @type {Array<Trade>}
     * @memberof ListTradesResponse
     */
    'result': Array<Trade>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Transfer
 */
interface Transfer {
    /**
     * Ethereum address of the user who received this transfer
     * @type {string}
     * @memberof Transfer
     */
    'receiver': string;
    /**
     * Status of the transaction
     * @type {string}
     * @memberof Transfer
     */
    'status': string;
    /**
     * Timestamp of the transfer
     * @type {string}
     * @memberof Transfer
     */
    'timestamp': string | null;
    /**
     *
     * @type {Token}
     * @memberof Transfer
     */
    'token': Token;
    /**
     * Sequential transaction ID
     * @type {number}
     * @memberof Transfer
     */
    'transaction_id': number;
    /**
     * Ethereum address of the user  who submitted this transfer
     * @type {string}
     * @memberof Transfer
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListTransfersResponse
 */
interface ListTransfersResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListTransfersResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListTransfersResponse
     */
    'remaining': number;
    /**
     * Transfers matching query parameters
     * @type {Array<Transfer>}
     * @memberof ListTransfersResponse
     */
    'result': Array<Transfer>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Withdrawal
 */
interface Withdrawal {
    /**
     * Status of the on-chain batch confirmation for this withdrawal
     * @type {string}
     * @memberof Withdrawal
     */
    'rollup_status': string;
    /**
     * Ethereum address of the user who requested this withdrawal
     * @type {string}
     * @memberof Withdrawal
     */
    'sender': string;
    /**
     * Status of this withdrawal
     * @type {string}
     * @memberof Withdrawal
     */
    'status': string;
    /**
     * Time when this withdrawal was initiated
     * @type {string}
     * @memberof Withdrawal
     */
    'timestamp': string;
    /**
     *
     * @type {Token}
     * @memberof Withdrawal
     */
    'token': Token;
    /**
     * Sequential ID of this transaction
     * @type {number}
     * @memberof Withdrawal
     */
    'transaction_id': number;
    /**
     * Withdrawal has been transferred to user\'s Layer 1 wallet
     * @type {boolean}
     * @memberof Withdrawal
     */
    'withdrawn_to_wallet': boolean;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListWithdrawalsResponse
 */
interface ListWithdrawalsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof ListWithdrawalsResponse
     */
    'cursor': string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof ListWithdrawalsResponse
     */
    'remaining': number;
    /**
     * Withdrawals matching query parameters
     * @type {Array<Withdrawal>}
     * @memberof ListWithdrawalsResponse
     */
    'result': Array<Withdrawal>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MetadataSchemaProperty
 */
interface MetadataSchemaProperty {
    /**
     * Sets the metadata as filterable
     * @type {boolean}
     * @memberof MetadataSchemaProperty
     */
    'filterable': boolean;
    /**
     * Name of the metadata key
     * @type {string}
     * @memberof MetadataSchemaProperty
     */
    'name': string;
    /**
     * Type of the metadata. Values: \"enum\", \"text\", \"boolean\", \"continuous\", \"discrete\" | Default: \"text\". Src: https://docs.x.immutable.com/docs/asset-metadata#property-type-mapping
     * @type {string}
     * @memberof MetadataSchemaProperty
     */
    'type': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MintFee
 */
interface MintFee {
    /**
     * Fee percentage
     * @type {number}
     * @memberof MintFee
     */
    'percentage': number;
    /**
     * Recipient wallet address
     * @type {string}
     * @memberof MintFee
     */
    'recipient': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MintTokenDataV2
 */
interface MintTokenDataV2 {
    /**
     * Token metadata blueprint
     * @type {string}
     * @memberof MintTokenDataV2
     */
    'blueprint': string;
    /**
     * Token ID Note: While the Token ID is required to be a string, it still needs to be a valid uint256 as per the ERC-721 token standard.
     * @type {string}
     * @memberof MintTokenDataV2
     */
    'id': string;
    /**
     * List of mint fees
     * @type {Array<MintFee>}
     * @memberof MintTokenDataV2
     */
    'royalties'?: Array<MintFee>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MintUser
 */
interface MintUser {
    /**
     * List of Mint tokens
     * @type {Array<MintTokenDataV2>}
     * @memberof MintUser
     */
    'tokens': Array<MintTokenDataV2>;
    /**
     * User wallet address
     * @type {string}
     * @memberof MintUser
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MintRequest
 */
interface MintRequest {
    /**
     * Signature from authorised minter
     * @type {string}
     * @memberof MintRequest
     */
    'auth_signature': string;
    /**
     * minting contract
     * @type {string}
     * @memberof MintRequest
     */
    'contract_address': string;
    /**
     * Global contract-level royalty fees
     * @type {Array<MintFee>}
     * @memberof MintRequest
     */
    'royalties'?: Array<MintFee>;
    /**
     * Users to mint to
     * @type {Array<MintUser>}
     * @memberof MintRequest
     */
    'users': Array<MintUser>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MintResultDetails
 */
interface MintResultDetails {
    /**
     * Contract address of this token
     * @type {string}
     * @memberof MintResultDetails
     */
    'contract_address': string;
    /**
     * IMX ID of this token
     * @type {string}
     * @memberof MintResultDetails
     */
    'token_id': string;
    /**
     * Mint Transaction ID
     * @type {number}
     * @memberof MintResultDetails
     */
    'tx_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MintTokensResponse
 */
interface MintTokensResponse {
    /**
     * List of mint result details
     * @type {Array<MintResultDetails>}
     * @memberof MintTokensResponse
     */
    'results': Array<MintResultDetails>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface MintableTokenDetails
 */
interface MintableTokenDetails {
    /**
     * Blueprint of this token
     * @type {string}
     * @memberof MintableTokenDetails
     */
    'blueprint': string;
    /**
     * ID provided by the client for this token
     * @type {string}
     * @memberof MintableTokenDetails
     */
    'client_token_id': string;
    /**
     * IMX Id of this token
     * @type {string}
     * @memberof MintableTokenDetails
     */
    'token_id': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NftprimarytransactionWidgetParams
 */
interface NftprimarytransactionWidgetParams {
    /**
     * enums(light, dark)
     * @type {string}
     * @memberof NftprimarytransactionWidgetParams
     */
    'theme'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NftprimarytransactionCreateAPIRequest
 */
interface NftprimarytransactionCreateAPIRequest {
    /**
     * Contract address of the asset to be created
     * @type {string}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'contract_address'?: string;
    /**
     * Temporary asset id
     * @type {string}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'offer_id'?: string;
    /**
     * Provider name
     * @type {string}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'provider'?: string;
    /**
     * Ethereum address of the user who wants to create transaction
     * @type {string}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'user_wallet_address'?: string;
    /**
     *
     * @type {NftprimarytransactionWidgetParams}
     * @memberof NftprimarytransactionCreateAPIRequest
     */
    'widget'?: NftprimarytransactionWidgetParams;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NftprimarytransactionCreateResponse
 */
interface NftprimarytransactionCreateResponse {
    /**
     * Contract address of the asset to be created
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'contract_address'?: string;
    /**
     * Temporary asset id. Might be a token id if the token id is known or a generic description if it\'s not
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'offer_id'?: string;
    /**
     * Provider name
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'provider'?: string;
    /**
     * Wallet address that will receive the payment (in crypto) from the checkout provider for the minted NFT
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'seller_wallet_address'?: string;
    /**
     * ID of the token that has been successfully minted - should be the same as `offer_id`
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'token_id'?: string;
    /**
     * Transaction id
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'transaction_id'?: string;
    /**
     * NFT purchase URL given by the checkout provider that the user can use to complete payment
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'url'?: string;
    /**
     * Ethereum address of the user who wants to create transaction
     * @type {string}
     * @memberof NftprimarytransactionCreateResponse
     */
    'user_wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NftprimarytransactionGetResponse
 */
interface NftprimarytransactionGetResponse {
    /**
     * Contract address of the asset
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'contract_address'?: string;
    /**
     * Temporary asset id. Might be a token id if the token id is known or a generic description if it\'s not
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'offer_id'?: string;
    /**
     * Provider name
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'provider'?: string;
    /**
     * Ethereum address of the seller
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'seller_wallet_address'?: string;
    /**
     * Transaction status enums(created, waitingPayment, pending, completed, failed)
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'status'?: string;
    /**
     * ID of the token that has been successfully minted - might or not be the same as `offer_id`
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'token_id'?: string;
    /**
     * Transaction id
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'transaction_id'?: string;
    /**
     * Wallet address that receives the minted NFT
     * @type {string}
     * @memberof NftprimarytransactionGetResponse
     */
    'user_wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NftprimarytransactionTransactionData
 */
interface NftprimarytransactionTransactionData {
    /**
     * Contract address of the asset
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'contract_address'?: string;
    /**
     * Timestamp when the transaction was created
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'created_at'?: string;
    /**
     * External transaction id
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'external_id'?: string;
    /**
     * Fees to pay on this transaction
     * @type {number}
     * @memberof NftprimarytransactionTransactionData
     */
    'fees_amount'?: number;
    /**
     * Amount of the currency specified in `from_currency` that the buyer paid for the transaction
     * @type {number}
     * @memberof NftprimarytransactionTransactionData
     */
    'from_amount'?: number;
    /**
     * Currency that the buyer used for the transaction
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'from_currency'?: string;
    /**
     * Minting transaction ID - see mintTokens response
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'mint_id'?: string;
    /**
     * Mint status
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'mint_status'?: string;
    /**
     * Temporary asset id. Might be a token id if the token id is known or a generic description if it\'s not
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'offer_id'?: string;
    /**
     * Provider name
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'provider'?: string;
    /**
     * Ethereum address of the seller
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'seller_wallet_address'?: string;
    /**
     * Transaction status enums(created, waitingPayment, pending, completed, failed)
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'status'?: string;
    /**
     * Amount of the currency specified in `to_currency` that the seller received from the checkout provider for the transaction
     * @type {number}
     * @memberof NftprimarytransactionTransactionData
     */
    'to_amount'?: number;
    /**
     * Currency (crypto) that the checkout provider sent to the seller for the transaction
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'to_currency'?: string;
    /**
     * ID of the token that has been successfully minted - should be the same as `offer_id`
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'token_id'?: string;
    /**
     * Transaction id
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'transaction_id'?: string;
    /**
     * Timestamp when the transaction was updated
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'updated_at'?: string;
    /**
     * Wallet address that receives the minted NFT
     * @type {string}
     * @memberof NftprimarytransactionTransactionData
     */
    'user_wallet_address'?: string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NftprimarytransactionListTransactionsResponse
 */
interface NftprimarytransactionListTransactionsResponse {
    /**
     * Generated cursor returned by previous query
     * @type {string}
     * @memberof NftprimarytransactionListTransactionsResponse
     */
    'cursor'?: string;
    /**
     * Remaining results flag. 1: there are remaining results matching this query, 0: no remaining results
     * @type {number}
     * @memberof NftprimarytransactionListTransactionsResponse
     */
    'remaining'?: number;
    /**
     * Transactions matching query parameters
     * @type {Array<NftprimarytransactionTransactionData>}
     * @memberof NftprimarytransactionListTransactionsResponse
     */
    'result'?: Array<NftprimarytransactionTransactionData>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface RegisterUserRequest
 */
interface RegisterUserRequest {
    /**
     * User email
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'email'?: string;
    /**
     * Eth signature
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'eth_signature': string;
    /**
     * The ether key of the user
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'ether_key': string;
    /**
     * Public stark key of the user
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'stark_key': string;
    /**
     * Payload signature
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'stark_signature': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface RegisterUserResponse
 */
interface RegisterUserResponse {
    /**
     * Immutable signature authorising registration
     * @type {string}
     * @memberof RegisterUserResponse
     */
    'tx_hash': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface SuccessResponse
 */
interface SuccessResponse {
    /**
     *
     * @type {string}
     * @memberof SuccessResponse
     */
    'result': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface UpdateCollectionRequest
 */
interface UpdateCollectionRequest {
    /**
     * URL of the tile image for this collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'collection_image_url'?: string;
    /**
     * Description of the collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the icon for this collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'icon_url'?: string;
    /**
     * URL of the metadata for this collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'metadata_api_url'?: string;
    /**
     * Name of the collection
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'name'?: string;
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
declare const AssetsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get details of an asset
     * @summary Get details of an asset
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId Either ERC721 token ID or internal IMX ID
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset: (tokenAddress: string, tokenId: string, includeFees?: boolean, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of assets
     * @summary Get a list of assets
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'updated_at' | 'name'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who owns these assets
     * @param {'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned'} [status] Status of these assets
     * @param {string} [name] Name of the asset to search
     * @param {string} [metadata] URL JSON-encoded metadata filters for these assets. Javascript example: encodeURI(JSON.stringify({\&#39;proto\&#39;:[\&#39;1147\&#39;],\&#39;quality\&#39;:[\&#39;Meteorite\&#39;]}))
     * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
     * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {string} [collection] Collection contract address
     * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAssets: (pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: 'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned', name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AssetsApi - functional programming interface
 * @export
 */
declare const AssetsApiFp: (configuration?: Configuration) => {
    /**
     * Get details of an asset
     * @summary Get details of an asset
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId Either ERC721 token ID or internal IMX ID
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>>;
    /**
     * Get a list of assets
     * @summary Get a list of assets
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'updated_at' | 'name'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who owns these assets
     * @param {'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned'} [status] Status of these assets
     * @param {string} [name] Name of the asset to search
     * @param {string} [metadata] URL JSON-encoded metadata filters for these assets. Javascript example: encodeURI(JSON.stringify({\&#39;proto\&#39;:[\&#39;1147\&#39;],\&#39;quality\&#39;:[\&#39;Meteorite\&#39;]}))
     * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
     * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {string} [collection] Collection contract address
     * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAssets(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: 'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned', name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAssetsResponse>>;
};
/**
 * AssetsApi - factory interface
 * @export
 */
declare const AssetsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get details of an asset
     * @summary Get details of an asset
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId Either ERC721 token ID or internal IMX ID
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: any): AxiosPromise<Asset>;
    /**
     * Get a list of assets
     * @summary Get a list of assets
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'updated_at' | 'name'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who owns these assets
     * @param {'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned'} [status] Status of these assets
     * @param {string} [name] Name of the asset to search
     * @param {string} [metadata] URL JSON-encoded metadata filters for these assets. Javascript example: encodeURI(JSON.stringify({\&#39;proto\&#39;:[\&#39;1147\&#39;],\&#39;quality\&#39;:[\&#39;Meteorite\&#39;]}))
     * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
     * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {string} [collection] Collection contract address
     * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAssets(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: 'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned', name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<ListAssetsResponse>;
};
/**
 * Request parameters for getAsset operation in AssetsApi.
 * @export
 * @interface AssetsApiGetAssetRequest
 */
interface AssetsApiGetAssetRequest {
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof AssetsApiGetAsset
     */
    readonly tokenAddress: string;
    /**
     * Either ERC721 token ID or internal IMX ID
     * @type {string}
     * @memberof AssetsApiGetAsset
     */
    readonly tokenId: string;
    /**
     * Set flag to include fees associated with the asset
     * @type {boolean}
     * @memberof AssetsApiGetAsset
     */
    readonly includeFees?: boolean;
}
/**
 * Request parameters for listAssets operation in AssetsApi.
 * @export
 * @interface AssetsApiListAssetsRequest
 */
interface AssetsApiListAssetsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof AssetsApiListAssets
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'updated_at' | 'name'}
     * @memberof AssetsApiListAssets
     */
    readonly orderBy?: 'updated_at' | 'name';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who owns these assets
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly user?: string;
    /**
     * Status of these assets
     * @type {'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned'}
     * @memberof AssetsApiListAssets
     */
    readonly status?: 'eth' | 'imx' | 'preparing_withdrawal' | 'withdrawable' | 'burned';
    /**
     * Name of the asset to search
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly name?: string;
    /**
     * URL JSON-encoded metadata filters for these assets. Javascript example: encodeURI(JSON.stringify({\&#39;proto\&#39;:[\&#39;1147\&#39;],\&#39;quality\&#39;:[\&#39;Meteorite\&#39;]}))
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly metadata?: string;
    /**
     * Set flag to true to fetch an array of sell order details with accepted status associated with the asset
     * @type {boolean}
     * @memberof AssetsApiListAssets
     */
    readonly sellOrders?: boolean;
    /**
     * Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
     * @type {boolean}
     * @memberof AssetsApiListAssets
     */
    readonly buyOrders?: boolean;
    /**
     * Set flag to include fees associated with the asset
     * @type {boolean}
     * @memberof AssetsApiListAssets
     */
    readonly includeFees?: boolean;
    /**
     * Collection contract address
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly collection?: string;
    /**
     * Minimum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly updatedMinTimestamp?: string;
    /**
     * Maximum timestamp for when these assets were last updated, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly updatedMaxTimestamp?: string;
    /**
     * Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly auxiliaryFeePercentages?: string;
    /**
     * Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @type {string}
     * @memberof AssetsApiListAssets
     */
    readonly auxiliaryFeeRecipients?: string;
}
/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
declare class AssetsApi extends BaseAPI {
    /**
     * Get details of an asset
     * @summary Get details of an asset
     * @param {AssetsApiGetAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    getAsset(requestParameters: AssetsApiGetAssetRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Asset, any>>;
    /**
     * Get a list of assets
     * @summary Get a list of assets
     * @param {AssetsApiListAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    listAssets(requestParameters?: AssetsApiListAssetsRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListAssetsResponse, any>>;
}

/**
 * BalancesApi - axios parameter creator
 * @export
 */
declare const BalancesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Fetches the token balances of the user
     * @summary Fetches the token balances of the user
     * @param {string} owner Address of the owner/user
     * @param {string} address Token address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance: (owner: string, address: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of balances for given user
     * @summary Get a list of balances for given user
     * @param {string} owner Ethereum wallet address for user
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBalances: (owner: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BalancesApi - functional programming interface
 * @export
 */
declare const BalancesApiFp: (configuration?: Configuration) => {
    /**
     * Fetches the token balances of the user
     * @summary Fetches the token balances of the user
     * @param {string} owner Address of the owner/user
     * @param {string} address Token address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance(owner: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>>;
    /**
     * Get a list of balances for given user
     * @summary Get a list of balances for given user
     * @param {string} owner Ethereum wallet address for user
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBalances(owner: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBalancesResponse>>;
};
/**
 * BalancesApi - factory interface
 * @export
 */
declare const BalancesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Fetches the token balances of the user
     * @summary Fetches the token balances of the user
     * @param {string} owner Address of the owner/user
     * @param {string} address Token address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance(owner: string, address: string, options?: any): AxiosPromise<Balance>;
    /**
     * Get a list of balances for given user
     * @summary Get a list of balances for given user
     * @param {string} owner Ethereum wallet address for user
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBalances(owner: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: any): AxiosPromise<ListBalancesResponse>;
};
/**
 * Request parameters for getBalance operation in BalancesApi.
 * @export
 * @interface BalancesApiGetBalanceRequest
 */
interface BalancesApiGetBalanceRequest {
    /**
     * Address of the owner/user
     * @type {string}
     * @memberof BalancesApiGetBalance
     */
    readonly owner: string;
    /**
     * Token address
     * @type {string}
     * @memberof BalancesApiGetBalance
     */
    readonly address: string;
}
/**
 * Request parameters for listBalances operation in BalancesApi.
 * @export
 * @interface BalancesApiListBalancesRequest
 */
interface BalancesApiListBalancesRequest {
    /**
     * Ethereum wallet address for user
     * @type {string}
     * @memberof BalancesApiListBalances
     */
    readonly owner: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof BalancesApiListBalances
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof BalancesApiListBalances
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {string}
     * @memberof BalancesApiListBalances
     */
    readonly orderBy?: string;
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof BalancesApiListBalances
     */
    readonly direction?: string;
}
/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
declare class BalancesApi extends BaseAPI {
    /**
     * Fetches the token balances of the user
     * @summary Fetches the token balances of the user
     * @param {BalancesApiGetBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    getBalance(requestParameters: BalancesApiGetBalanceRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Balance, any>>;
    /**
     * Get a list of balances for given user
     * @summary Get a list of balances for given user
     * @param {BalancesApiListBalancesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    listBalances(requestParameters: BalancesApiListBalancesRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListBalancesResponse, any>>;
}

/**
 * CollectionsApi - axios parameter creator
 * @export
 */
declare const CollectionsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create collection
     * @summary Create collection
     * @param {string} iMXSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {CreateCollectionRequest} createCollectionRequest create a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection: (iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get details of a collection at the given address
     * @summary Get details of a collection at the given address
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection: (address: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of collection filters
     * @summary Get a list of collection filters
     * @param {string} address Collection contract address
     * @param {number} [pageSize] Page size of the result
     * @param {string} [nextPageToken] Next page token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionFilters: (address: string, pageSize?: number, nextPageToken?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of collections
     * @summary Get a list of collections
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'name' | 'address' | 'project_id' | 'created_at' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [blacklist] List of collections not to be included, separated by commas
     * @param {string} [whitelist] List of collections to be included, separated by commas
     * @param {string} [keyword] Keyword to search in collection name and description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections: (pageSize?: number, cursor?: string, orderBy?: 'name' | 'address' | 'project_id' | 'created_at' | 'updated_at', direction?: string, blacklist?: string, whitelist?: string, keyword?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update collection
     * @summary Update collection
     * @param {string} address Collection contract address
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection: (address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
declare const CollectionsApiFp: (configuration?: Configuration) => {
    /**
     * Create collection
     * @summary Create collection
     * @param {string} iMXSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {CreateCollectionRequest} createCollectionRequest create a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>>;
    /**
     * Get details of a collection at the given address
     * @summary Get details of a collection at the given address
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>>;
    /**
     * Get a list of collection filters
     * @summary Get a list of collection filters
     * @param {string} address Collection contract address
     * @param {number} [pageSize] Page size of the result
     * @param {string} [nextPageToken] Next page token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionFilters(address: string, pageSize?: number, nextPageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionFilter>>;
    /**
     * Get a list of collections
     * @summary Get a list of collections
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'name' | 'address' | 'project_id' | 'created_at' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [blacklist] List of collections not to be included, separated by commas
     * @param {string} [whitelist] List of collections to be included, separated by commas
     * @param {string} [keyword] Keyword to search in collection name and description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(pageSize?: number, cursor?: string, orderBy?: 'name' | 'address' | 'project_id' | 'created_at' | 'updated_at', direction?: string, blacklist?: string, whitelist?: string, keyword?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionsResponse>>;
    /**
     * Update collection
     * @summary Update collection
     * @param {string} address Collection contract address
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection(address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>>;
};
/**
 * CollectionsApi - factory interface
 * @export
 */
declare const CollectionsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create collection
     * @summary Create collection
     * @param {string} iMXSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {CreateCollectionRequest} createCollectionRequest create a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options?: any): AxiosPromise<Collection>;
    /**
     * Get details of a collection at the given address
     * @summary Get details of a collection at the given address
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(address: string, options?: any): AxiosPromise<Collection>;
    /**
     * Get a list of collection filters
     * @summary Get a list of collection filters
     * @param {string} address Collection contract address
     * @param {number} [pageSize] Page size of the result
     * @param {string} [nextPageToken] Next page token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionFilters(address: string, pageSize?: number, nextPageToken?: string, options?: any): AxiosPromise<CollectionFilter>;
    /**
     * Get a list of collections
     * @summary Get a list of collections
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'name' | 'address' | 'project_id' | 'created_at' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [blacklist] List of collections not to be included, separated by commas
     * @param {string} [whitelist] List of collections to be included, separated by commas
     * @param {string} [keyword] Keyword to search in collection name and description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(pageSize?: number, cursor?: string, orderBy?: 'name' | 'address' | 'project_id' | 'created_at' | 'updated_at', direction?: string, blacklist?: string, whitelist?: string, keyword?: string, options?: any): AxiosPromise<ListCollectionsResponse>;
    /**
     * Update collection
     * @summary Update collection
     * @param {string} address Collection contract address
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection(address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options?: any): AxiosPromise<Collection>;
};
/**
 * Request parameters for createCollection operation in CollectionsApi.
 * @export
 * @interface CollectionsApiCreateCollectionRequest
 */
interface CollectionsApiCreateCollectionRequest {
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof CollectionsApiCreateCollection
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof CollectionsApiCreateCollection
     */
    readonly iMXTimestamp: string;
    /**
     * create a collection
     * @type {CreateCollectionRequest}
     * @memberof CollectionsApiCreateCollection
     */
    readonly createCollectionRequest: CreateCollectionRequest;
}
/**
 * Request parameters for getCollection operation in CollectionsApi.
 * @export
 * @interface CollectionsApiGetCollectionRequest
 */
interface CollectionsApiGetCollectionRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof CollectionsApiGetCollection
     */
    readonly address: string;
}
/**
 * Request parameters for listCollectionFilters operation in CollectionsApi.
 * @export
 * @interface CollectionsApiListCollectionFiltersRequest
 */
interface CollectionsApiListCollectionFiltersRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof CollectionsApiListCollectionFilters
     */
    readonly address: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof CollectionsApiListCollectionFilters
     */
    readonly pageSize?: number;
    /**
     * Next page token
     * @type {string}
     * @memberof CollectionsApiListCollectionFilters
     */
    readonly nextPageToken?: string;
}
/**
 * Request parameters for listCollections operation in CollectionsApi.
 * @export
 * @interface CollectionsApiListCollectionsRequest
 */
interface CollectionsApiListCollectionsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof CollectionsApiListCollections
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'name' | 'address' | 'project_id' | 'created_at' | 'updated_at'}
     * @memberof CollectionsApiListCollections
     */
    readonly orderBy?: 'name' | 'address' | 'project_id' | 'created_at' | 'updated_at';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly direction?: string;
    /**
     * List of collections not to be included, separated by commas
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly blacklist?: string;
    /**
     * List of collections to be included, separated by commas
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly whitelist?: string;
    /**
     * Keyword to search in collection name and description
     * @type {string}
     * @memberof CollectionsApiListCollections
     */
    readonly keyword?: string;
}
/**
 * Request parameters for updateCollection operation in CollectionsApi.
 * @export
 * @interface CollectionsApiUpdateCollectionRequest
 */
interface CollectionsApiUpdateCollectionRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof CollectionsApiUpdateCollection
     */
    readonly address: string;
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof CollectionsApiUpdateCollection
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof CollectionsApiUpdateCollection
     */
    readonly iMXTimestamp: string;
    /**
     * update a collection
     * @type {UpdateCollectionRequest}
     * @memberof CollectionsApiUpdateCollection
     */
    readonly updateCollectionRequest: UpdateCollectionRequest;
}
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
declare class CollectionsApi extends BaseAPI {
    /**
     * Create collection
     * @summary Create collection
     * @param {CollectionsApiCreateCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    createCollection(requestParameters: CollectionsApiCreateCollectionRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Collection, any>>;
    /**
     * Get details of a collection at the given address
     * @summary Get details of a collection at the given address
     * @param {CollectionsApiGetCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollection(requestParameters: CollectionsApiGetCollectionRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Collection, any>>;
    /**
     * Get a list of collection filters
     * @summary Get a list of collection filters
     * @param {CollectionsApiListCollectionFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollectionFilters(requestParameters: CollectionsApiListCollectionFiltersRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CollectionFilter, any>>;
    /**
     * Get a list of collections
     * @summary Get a list of collections
     * @param {CollectionsApiListCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollections(requestParameters?: CollectionsApiListCollectionsRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListCollectionsResponse, any>>;
    /**
     * Update collection
     * @summary Update collection
     * @param {CollectionsApiUpdateCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    updateCollection(requestParameters: CollectionsApiUpdateCollectionRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Collection, any>>;
}

/**
 * DepositsApi - axios parameter creator
 * @export
 */
declare const DepositsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get details of a deposit with the given ID
     * @summary Get details of a deposit with the given ID
     * @param {string} id Deposit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeposit: (id: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Gets details of a signable deposit
     * @summary Gets details of a signable deposit
     * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableDeposit: (getSignableDepositRequest: GetSignableDepositRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of deposits
     * @summary Get a list of deposits
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this deposit
     * @param {string} [status] Status of this deposit
     * @param {string} [minTimestamp] Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the deposited asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the deposited asset
     * @param {string} [tokenName] Token name of the deposited asset
     * @param {string} [minQuantity] Min quantity for the deposited asset
     * @param {string} [maxQuantity] Max quantity for the deposited asset
     * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDeposits: (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * DepositsApi - functional programming interface
 * @export
 */
declare const DepositsApiFp: (configuration?: Configuration) => {
    /**
     * Get details of a deposit with the given ID
     * @summary Get details of a deposit with the given ID
     * @param {string} id Deposit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeposit(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deposit>>;
    /**
     * Gets details of a signable deposit
     * @summary Gets details of a signable deposit
     * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableDeposit(getSignableDepositRequest: GetSignableDepositRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableDepositResponse>>;
    /**
     * Get a list of deposits
     * @summary Get a list of deposits
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this deposit
     * @param {string} [status] Status of this deposit
     * @param {string} [minTimestamp] Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the deposited asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the deposited asset
     * @param {string} [tokenName] Token name of the deposited asset
     * @param {string} [minQuantity] Min quantity for the deposited asset
     * @param {string} [maxQuantity] Max quantity for the deposited asset
     * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDeposits(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDepositsResponse>>;
};
/**
 * DepositsApi - factory interface
 * @export
 */
declare const DepositsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get details of a deposit with the given ID
     * @summary Get details of a deposit with the given ID
     * @param {string} id Deposit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeposit(id: string, options?: any): AxiosPromise<Deposit>;
    /**
     * Gets details of a signable deposit
     * @summary Gets details of a signable deposit
     * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableDeposit(getSignableDepositRequest: GetSignableDepositRequest, options?: any): AxiosPromise<GetSignableDepositResponse>;
    /**
     * Get a list of deposits
     * @summary Get a list of deposits
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this deposit
     * @param {string} [status] Status of this deposit
     * @param {string} [minTimestamp] Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the deposited asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the deposited asset
     * @param {string} [tokenName] Token name of the deposited asset
     * @param {string} [minQuantity] Min quantity for the deposited asset
     * @param {string} [maxQuantity] Max quantity for the deposited asset
     * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDeposits(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListDepositsResponse>;
};
/**
 * Request parameters for getDeposit operation in DepositsApi.
 * @export
 * @interface DepositsApiGetDepositRequest
 */
interface DepositsApiGetDepositRequest {
    /**
     * Deposit ID
     * @type {string}
     * @memberof DepositsApiGetDeposit
     */
    readonly id: string;
}
/**
 * Request parameters for getSignableDeposit operation in DepositsApi.
 * @export
 * @interface DepositsApiGetSignableDepositRequest
 */
interface DepositsApiGetSignableDepositRequest {
    /**
     * Get details of signable deposit
     * @type {GetSignableDepositRequest}
     * @memberof DepositsApiGetSignableDeposit
     */
    readonly getSignableDepositRequest: GetSignableDepositRequest;
}
/**
 * Request parameters for listDeposits operation in DepositsApi.
 * @export
 * @interface DepositsApiListDepositsRequest
 */
interface DepositsApiListDepositsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof DepositsApiListDeposits
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly orderBy?: string;
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this deposit
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly user?: string;
    /**
     * Status of this deposit
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly status?: string;
    /**
     * Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly maxTimestamp?: string;
    /**
     * Token type of the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly tokenType?: string;
    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly tokenId?: string;
    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly assetId?: string;
    /**
     * Token address of the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly tokenAddress?: string;
    /**
     * Token name of the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly tokenName?: string;
    /**
     * Min quantity for the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly minQuantity?: string;
    /**
     * Max quantity for the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly maxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the deposited asset
     * @type {string}
     * @memberof DepositsApiListDeposits
     */
    readonly metadata?: string;
}
/**
 * DepositsApi - object-oriented interface
 * @export
 * @class DepositsApi
 * @extends {BaseAPI}
 */
declare class DepositsApi extends BaseAPI {
    /**
     * Get details of a deposit with the given ID
     * @summary Get details of a deposit with the given ID
     * @param {DepositsApiGetDepositRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    getDeposit(requestParameters: DepositsApiGetDepositRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Deposit, any>>;
    /**
     * Gets details of a signable deposit
     * @summary Gets details of a signable deposit
     * @param {DepositsApiGetSignableDepositRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    getSignableDeposit(requestParameters: DepositsApiGetSignableDepositRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableDepositResponse, any>>;
    /**
     * Get a list of deposits
     * @summary Get a list of deposits
     * @param {DepositsApiListDepositsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    listDeposits(requestParameters?: DepositsApiListDepositsRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListDepositsResponse, any>>;
}

/**
 * EncodingApi - axios parameter creator
 * @export
 */
declare const EncodingApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieves the Starkex Encoded format for a given asset so that it can be used as parameter for Starkex smart contracts
     * @summary Retrieves the Starkex Encoded format for a given asset
     * @param {string} assetType Asset type to be encoded. (asset/mintable-asset)
     * @param {EncodeAssetRequest} encodeAssetRequest Encode Asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    encodeAsset: (assetType: string, encodeAssetRequest: EncodeAssetRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * EncodingApi - functional programming interface
 * @export
 */
declare const EncodingApiFp: (configuration?: Configuration) => {
    /**
     * Retrieves the Starkex Encoded format for a given asset so that it can be used as parameter for Starkex smart contracts
     * @summary Retrieves the Starkex Encoded format for a given asset
     * @param {string} assetType Asset type to be encoded. (asset/mintable-asset)
     * @param {EncodeAssetRequest} encodeAssetRequest Encode Asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    encodeAsset(assetType: string, encodeAssetRequest: EncodeAssetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EncodeAssetResponse>>;
};
/**
 * EncodingApi - factory interface
 * @export
 */
declare const EncodingApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieves the Starkex Encoded format for a given asset so that it can be used as parameter for Starkex smart contracts
     * @summary Retrieves the Starkex Encoded format for a given asset
     * @param {string} assetType Asset type to be encoded. (asset/mintable-asset)
     * @param {EncodeAssetRequest} encodeAssetRequest Encode Asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    encodeAsset(assetType: string, encodeAssetRequest: EncodeAssetRequest, options?: any): AxiosPromise<EncodeAssetResponse>;
};
/**
 * Request parameters for encodeAsset operation in EncodingApi.
 * @export
 * @interface EncodingApiEncodeAssetRequest
 */
interface EncodingApiEncodeAssetRequest {
    /**
     * Asset type to be encoded. (asset/mintable-asset)
     * @type {string}
     * @memberof EncodingApiEncodeAsset
     */
    readonly assetType: string;
    /**
     * Encode Asset
     * @type {EncodeAssetRequest}
     * @memberof EncodingApiEncodeAsset
     */
    readonly encodeAssetRequest: EncodeAssetRequest;
}
/**
 * EncodingApi - object-oriented interface
 * @export
 * @class EncodingApi
 * @extends {BaseAPI}
 */
declare class EncodingApi extends BaseAPI {
    /**
     * Retrieves the Starkex Encoded format for a given asset so that it can be used as parameter for Starkex smart contracts
     * @summary Retrieves the Starkex Encoded format for a given asset
     * @param {EncodingApiEncodeAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncodingApi
     */
    encodeAsset(requestParameters: EncodingApiEncodeAssetRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<EncodeAssetResponse, any>>;
}

/**
 * ExchangesApi - axios parameter creator
 * @export
 */
declare const ExchangesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Receive wallet_address, provider, type and widget information to create a base exchange transaction and return widget URL
     * @summary Create an exchange with URL
     * @param {CreateExchangeAndURLAPIRequest} createExchangeAPIRequest req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExchange: (createExchangeAPIRequest: CreateExchangeAndURLAPIRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @summary Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @param {string} id Transaction ID
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTransferRequestV1} createTransferRequest Create a transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExchangeTransfer: (id: string, xImxEthAddress: string, xImxEthSignature: string, createTransferRequest: CreateTransferRequestV1, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get an exchange by ID
     * @summary Get an exchange by ID
     * @param {string} id Exchange ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchange: (id: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Send a request for signable-transfer-details (offramp)
     * @summary Send a request for signable-transfer-details (offramp)
     * @param {string} id Transaction ID
     * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchangeSignableTransfer: (id: string, getSignableTransferRequest: GetSignableTransferRequestV1, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of exchanges based on the request
     * @summary Returns a list of exchanges based on the request
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'id' | 'status' | 'exchange' | 'amount' | 'transfer_id'} [orderBy] Property to sort by
     * @param {'asc' | 'desc'} [direction] Direction to sort
     * @param {number} [id] Transaction ID
     * @param {string} [walletAddress] Ethereum address of the user who created transaction
     * @param {'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut'} [status] Transaction status
     * @param {'moonpay' | 'layerswap'} [provider] Provider name
     * @param {string} [transferId] Transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchanges: (pageSize?: number, cursor?: string, orderBy?: 'id' | 'status' | 'exchange' | 'amount' | 'transfer_id', direction?: 'asc' | 'desc', id?: number, walletAddress?: string, status?: 'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut', provider?: 'moonpay' | 'layerswap', transferId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ExchangesApi - functional programming interface
 * @export
 */
declare const ExchangesApiFp: (configuration?: Configuration) => {
    /**
     * Receive wallet_address, provider, type and widget information to create a base exchange transaction and return widget URL
     * @summary Create an exchange with URL
     * @param {CreateExchangeAndURLAPIRequest} createExchangeAPIRequest req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExchange(createExchangeAPIRequest: CreateExchangeAndURLAPIRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeCreateExchangeAndURLResponse>>;
    /**
     * Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @summary Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @param {string} id Transaction ID
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTransferRequestV1} createTransferRequest Create a transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExchangeTransfer(id: string, xImxEthAddress: string, xImxEthSignature: string, createTransferRequest: CreateTransferRequestV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferResponseV1>>;
    /**
     * Get an exchange by ID
     * @summary Get an exchange by ID
     * @param {string} id Exchange ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchange(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exchange>>;
    /**
     * Send a request for signable-transfer-details (offramp)
     * @summary Send a request for signable-transfer-details (offramp)
     * @param {string} id Transaction ID
     * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchangeSignableTransfer(id: string, getSignableTransferRequest: GetSignableTransferRequestV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTransferResponseV1>>;
    /**
     * Returns a list of exchanges based on the request
     * @summary Returns a list of exchanges based on the request
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'id' | 'status' | 'exchange' | 'amount' | 'transfer_id'} [orderBy] Property to sort by
     * @param {'asc' | 'desc'} [direction] Direction to sort
     * @param {number} [id] Transaction ID
     * @param {string} [walletAddress] Ethereum address of the user who created transaction
     * @param {'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut'} [status] Transaction status
     * @param {'moonpay' | 'layerswap'} [provider] Provider name
     * @param {string} [transferId] Transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchanges(pageSize?: number, cursor?: string, orderBy?: 'id' | 'status' | 'exchange' | 'amount' | 'transfer_id', direction?: 'asc' | 'desc', id?: number, walletAddress?: string, status?: 'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut', provider?: 'moonpay' | 'layerswap', transferId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionsResponse>>;
};
/**
 * ExchangesApi - factory interface
 * @export
 */
declare const ExchangesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Receive wallet_address, provider, type and widget information to create a base exchange transaction and return widget URL
     * @summary Create an exchange with URL
     * @param {CreateExchangeAndURLAPIRequest} createExchangeAPIRequest req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExchange(createExchangeAPIRequest: CreateExchangeAndURLAPIRequest, options?: any): AxiosPromise<ExchangeCreateExchangeAndURLResponse>;
    /**
     * Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @summary Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @param {string} id Transaction ID
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTransferRequestV1} createTransferRequest Create a transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExchangeTransfer(id: string, xImxEthAddress: string, xImxEthSignature: string, createTransferRequest: CreateTransferRequestV1, options?: any): AxiosPromise<CreateTransferResponseV1>;
    /**
     * Get an exchange by ID
     * @summary Get an exchange by ID
     * @param {string} id Exchange ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchange(id: string, options?: any): AxiosPromise<Exchange>;
    /**
     * Send a request for signable-transfer-details (offramp)
     * @summary Send a request for signable-transfer-details (offramp)
     * @param {string} id Transaction ID
     * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchangeSignableTransfer(id: string, getSignableTransferRequest: GetSignableTransferRequestV1, options?: any): AxiosPromise<GetSignableTransferResponseV1>;
    /**
     * Returns a list of exchanges based on the request
     * @summary Returns a list of exchanges based on the request
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'id' | 'status' | 'exchange' | 'amount' | 'transfer_id'} [orderBy] Property to sort by
     * @param {'asc' | 'desc'} [direction] Direction to sort
     * @param {number} [id] Transaction ID
     * @param {string} [walletAddress] Ethereum address of the user who created transaction
     * @param {'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut'} [status] Transaction status
     * @param {'moonpay' | 'layerswap'} [provider] Provider name
     * @param {string} [transferId] Transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchanges(pageSize?: number, cursor?: string, orderBy?: 'id' | 'status' | 'exchange' | 'amount' | 'transfer_id', direction?: 'asc' | 'desc', id?: number, walletAddress?: string, status?: 'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut', provider?: 'moonpay' | 'layerswap', transferId?: string, options?: any): AxiosPromise<GetTransactionsResponse>;
};
/**
 * Request parameters for createExchange operation in ExchangesApi.
 * @export
 * @interface ExchangesApiCreateExchangeRequest
 */
interface ExchangesApiCreateExchangeRequest {
    /**
     * req
     * @type {CreateExchangeAndURLAPIRequest}
     * @memberof ExchangesApiCreateExchange
     */
    readonly createExchangeAPIRequest: CreateExchangeAndURLAPIRequest;
}
/**
 * Request parameters for createExchangeTransfer operation in ExchangesApi.
 * @export
 * @interface ExchangesApiCreateExchangeTransferRequest
 */
interface ExchangesApiCreateExchangeTransferRequest {
    /**
     * Transaction ID
     * @type {string}
     * @memberof ExchangesApiCreateExchangeTransfer
     */
    readonly id: string;
    /**
     * eth address
     * @type {string}
     * @memberof ExchangesApiCreateExchangeTransfer
     */
    readonly xImxEthAddress: string;
    /**
     * eth signature
     * @type {string}
     * @memberof ExchangesApiCreateExchangeTransfer
     */
    readonly xImxEthSignature: string;
    /**
     * Create a transfer
     * @type {CreateTransferRequestV1}
     * @memberof ExchangesApiCreateExchangeTransfer
     */
    readonly createTransferRequest: CreateTransferRequestV1;
}
/**
 * Request parameters for getExchange operation in ExchangesApi.
 * @export
 * @interface ExchangesApiGetExchangeRequest
 */
interface ExchangesApiGetExchangeRequest {
    /**
     * Exchange ID
     * @type {string}
     * @memberof ExchangesApiGetExchange
     */
    readonly id: string;
}
/**
 * Request parameters for getExchangeSignableTransfer operation in ExchangesApi.
 * @export
 * @interface ExchangesApiGetExchangeSignableTransferRequest
 */
interface ExchangesApiGetExchangeSignableTransferRequest {
    /**
     * Transaction ID
     * @type {string}
     * @memberof ExchangesApiGetExchangeSignableTransfer
     */
    readonly id: string;
    /**
     * get details of signable transfer
     * @type {GetSignableTransferRequestV1}
     * @memberof ExchangesApiGetExchangeSignableTransfer
     */
    readonly getSignableTransferRequest: GetSignableTransferRequestV1;
}
/**
 * Request parameters for getExchanges operation in ExchangesApi.
 * @export
 * @interface ExchangesApiGetExchangesRequest
 */
interface ExchangesApiGetExchangesRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof ExchangesApiGetExchanges
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof ExchangesApiGetExchanges
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'id' | 'status' | 'exchange' | 'amount' | 'transfer_id'}
     * @memberof ExchangesApiGetExchanges
     */
    readonly orderBy?: 'id' | 'status' | 'exchange' | 'amount' | 'transfer_id';
    /**
     * Direction to sort
     * @type {'asc' | 'desc'}
     * @memberof ExchangesApiGetExchanges
     */
    readonly direction?: 'asc' | 'desc';
    /**
     * Transaction ID
     * @type {number}
     * @memberof ExchangesApiGetExchanges
     */
    readonly id?: number;
    /**
     * Ethereum address of the user who created transaction
     * @type {string}
     * @memberof ExchangesApiGetExchanges
     */
    readonly walletAddress?: string;
    /**
     * Transaction status
     * @type {'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut'}
     * @memberof ExchangesApiGetExchanges
     */
    readonly status?: 'created' | 'pending' | 'completed' | 'failed' | 'waitingPayment' | 'timedOut';
    /**
     * Provider name
     * @type {'moonpay' | 'layerswap'}
     * @memberof ExchangesApiGetExchanges
     */
    readonly provider?: 'moonpay' | 'layerswap';
    /**
     * Transfer ID
     * @type {string}
     * @memberof ExchangesApiGetExchanges
     */
    readonly transferId?: string;
}
/**
 * ExchangesApi - object-oriented interface
 * @export
 * @class ExchangesApi
 * @extends {BaseAPI}
 */
declare class ExchangesApi extends BaseAPI {
    /**
     * Receive wallet_address, provider, type and widget information to create a base exchange transaction and return widget URL
     * @summary Create an exchange with URL
     * @param {ExchangesApiCreateExchangeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    createExchange(requestParameters: ExchangesApiCreateExchangeRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ExchangeCreateExchangeAndURLResponse, any>>;
    /**
     * Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @summary Accepts a transfer request and updates the transfer_status after processing transfer (offramp)
     * @param {ExchangesApiCreateExchangeTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    createExchangeTransfer(requestParameters: ExchangesApiCreateExchangeTransferRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateTransferResponseV1, any>>;
    /**
     * Get an exchange by ID
     * @summary Get an exchange by ID
     * @param {ExchangesApiGetExchangeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    getExchange(requestParameters: ExchangesApiGetExchangeRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Exchange, any>>;
    /**
     * Send a request for signable-transfer-details (offramp)
     * @summary Send a request for signable-transfer-details (offramp)
     * @param {ExchangesApiGetExchangeSignableTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    getExchangeSignableTransfer(requestParameters: ExchangesApiGetExchangeSignableTransferRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableTransferResponseV1, any>>;
    /**
     * Returns a list of exchanges based on the request
     * @summary Returns a list of exchanges based on the request
     * @param {ExchangesApiGetExchangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    getExchanges(requestParameters?: ExchangesApiGetExchangesRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetTransactionsResponse, any>>;
}

/**
 * MetadataApi - axios parameter creator
 * @export
 */
declare const MetadataApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Add metadata schema to collection
     * @summary Add metadata schema to collection
     * @param {string} address Collection contract address
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMetadataSchemaToCollection: (address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get collection metadata schema
     * @summary Get collection metadata schema
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataSchema: (address: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update metadata schema by name
     * @summary Update metadata schema by name
     * @param {string} address Collection contract address
     * @param {string} name Metadata schema name
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMetadataSchemaByName: (address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MetadataApi - functional programming interface
 * @export
 */
declare const MetadataApiFp: (configuration?: Configuration) => {
    /**
     * Add metadata schema to collection
     * @summary Add metadata schema to collection
     * @param {string} address Collection contract address
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMetadataSchemaToCollection(address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>>;
    /**
     * Get collection metadata schema
     * @summary Get collection metadata schema
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataSchema(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetadataSchemaProperty>>>;
    /**
     * Update metadata schema by name
     * @summary Update metadata schema by name
     * @param {string} address Collection contract address
     * @param {string} name Metadata schema name
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMetadataSchemaByName(address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>>;
};
/**
 * MetadataApi - factory interface
 * @export
 */
declare const MetadataApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Add metadata schema to collection
     * @summary Add metadata schema to collection
     * @param {string} address Collection contract address
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMetadataSchemaToCollection(address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options?: any): AxiosPromise<SuccessResponse>;
    /**
     * Get collection metadata schema
     * @summary Get collection metadata schema
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataSchema(address: string, options?: any): AxiosPromise<Array<MetadataSchemaProperty>>;
    /**
     * Update metadata schema by name
     * @summary Update metadata schema by name
     * @param {string} address Collection contract address
     * @param {string} name Metadata schema name
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMetadataSchemaByName(address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options?: any): AxiosPromise<SuccessResponse>;
};
/**
 * Request parameters for addMetadataSchemaToCollection operation in MetadataApi.
 * @export
 * @interface MetadataApiAddMetadataSchemaToCollectionRequest
 */
interface MetadataApiAddMetadataSchemaToCollectionRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof MetadataApiAddMetadataSchemaToCollection
     */
    readonly address: string;
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof MetadataApiAddMetadataSchemaToCollection
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataApiAddMetadataSchemaToCollection
     */
    readonly iMXTimestamp: string;
    /**
     * add metadata schema to a collection
     * @type {AddMetadataSchemaToCollectionRequest}
     * @memberof MetadataApiAddMetadataSchemaToCollection
     */
    readonly addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest;
}
/**
 * Request parameters for getMetadataSchema operation in MetadataApi.
 * @export
 * @interface MetadataApiGetMetadataSchemaRequest
 */
interface MetadataApiGetMetadataSchemaRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof MetadataApiGetMetadataSchema
     */
    readonly address: string;
}
/**
 * Request parameters for updateMetadataSchemaByName operation in MetadataApi.
 * @export
 * @interface MetadataApiUpdateMetadataSchemaByNameRequest
 */
interface MetadataApiUpdateMetadataSchemaByNameRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly address: string;
    /**
     * Metadata schema name
     * @type {string}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly name: string;
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly iMXTimestamp: string;
    /**
     * update metadata schema
     * @type {MetadataSchemaRequest}
     * @memberof MetadataApiUpdateMetadataSchemaByName
     */
    readonly metadataSchemaRequest: MetadataSchemaRequest;
}
/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
declare class MetadataApi extends BaseAPI {
    /**
     * Add metadata schema to collection
     * @summary Add metadata schema to collection
     * @param {MetadataApiAddMetadataSchemaToCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    addMetadataSchemaToCollection(requestParameters: MetadataApiAddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SuccessResponse, any>>;
    /**
     * Get collection metadata schema
     * @summary Get collection metadata schema
     * @param {MetadataApiGetMetadataSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    getMetadataSchema(requestParameters: MetadataApiGetMetadataSchemaRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<MetadataSchemaProperty[], any>>;
    /**
     * Update metadata schema by name
     * @summary Update metadata schema by name
     * @param {MetadataApiUpdateMetadataSchemaByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    updateMetadataSchemaByName(requestParameters: MetadataApiUpdateMetadataSchemaByNameRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SuccessResponse, any>>;
}

/**
 * MetadataRefreshesApi - axios parameter creator
 * @export
 */
declare const MetadataRefreshesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get a list of metadata refreshes
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [collectionAddress] Collection address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAListOfMetadataRefreshes: (xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, pageSize?: number, cursor?: string, collectionAddress?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get metadata refresh errors
     * @param {string} refreshId The metadata refresh ID
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataRefreshErrors: (refreshId: string, xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, pageSize?: number, cursor?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get metadata refresh results
     * @param {string} refreshId The metadata refresh ID
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataRefreshResults: (refreshId: string, xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Request metadata refresh for provided tokens
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {CreateMetadataRefreshRequest} createMetadataRefreshRequest Create metadata refresh request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestAMetadataRefresh: (xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, createMetadataRefreshRequest: CreateMetadataRefreshRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MetadataRefreshesApi - functional programming interface
 * @export
 */
declare const MetadataRefreshesApiFp: (configuration?: Configuration) => {
    /**
     * Get a list of metadata refreshes
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [collectionAddress] Collection address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAListOfMetadataRefreshes(xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, pageSize?: number, cursor?: string, collectionAddress?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetadataRefreshes>>;
    /**
     * Get metadata refresh errors
     * @param {string} refreshId The metadata refresh ID
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataRefreshErrors(refreshId: string, xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, pageSize?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetadataRefreshErrorsResponse>>;
    /**
     * Get metadata refresh results
     * @param {string} refreshId The metadata refresh ID
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataRefreshResults(refreshId: string, xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetadataRefreshResponse>>;
    /**
     * Request metadata refresh for provided tokens
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {CreateMetadataRefreshRequest} createMetadataRefreshRequest Create metadata refresh request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestAMetadataRefresh(xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, createMetadataRefreshRequest: CreateMetadataRefreshRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMetadataRefreshResponse>>;
};
/**
 * MetadataRefreshesApi - factory interface
 * @export
 */
declare const MetadataRefreshesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get a list of metadata refreshes
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [collectionAddress] Collection address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAListOfMetadataRefreshes(xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, pageSize?: number, cursor?: string, collectionAddress?: string, options?: any): AxiosPromise<GetMetadataRefreshes>;
    /**
     * Get metadata refresh errors
     * @param {string} refreshId The metadata refresh ID
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataRefreshErrors(refreshId: string, xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, pageSize?: number, cursor?: string, options?: any): AxiosPromise<GetMetadataRefreshErrorsResponse>;
    /**
     * Get metadata refresh results
     * @param {string} refreshId The metadata refresh ID
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataRefreshResults(refreshId: string, xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, options?: any): AxiosPromise<GetMetadataRefreshResponse>;
    /**
     * Request metadata refresh for provided tokens
     * @param {string} xImxEthSignature String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @param {string} xImxEthTimestamp Unix Epoc timestamp
     * @param {string} xImxEthAddress Wallet Address that signed the signature
     * @param {CreateMetadataRefreshRequest} createMetadataRefreshRequest Create metadata refresh request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestAMetadataRefresh(xImxEthSignature: string, xImxEthTimestamp: string, xImxEthAddress: string, createMetadataRefreshRequest: CreateMetadataRefreshRequest, options?: any): AxiosPromise<CreateMetadataRefreshResponse>;
};
/**
 * Request parameters for getAListOfMetadataRefreshes operation in MetadataRefreshesApi.
 * @export
 * @interface MetadataRefreshesApiGetAListOfMetadataRefreshesRequest
 */
interface MetadataRefreshesApiGetAListOfMetadataRefreshesRequest {
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly xImxEthSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly xImxEthTimestamp: string;
    /**
     * Wallet Address that signed the signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly xImxEthAddress: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly cursor?: string;
    /**
     * Collection address
     * @type {string}
     * @memberof MetadataRefreshesApiGetAListOfMetadataRefreshes
     */
    readonly collectionAddress?: string;
}
/**
 * Request parameters for getMetadataRefreshErrors operation in MetadataRefreshesApi.
 * @export
 * @interface MetadataRefreshesApiGetMetadataRefreshErrorsRequest
 */
interface MetadataRefreshesApiGetMetadataRefreshErrorsRequest {
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly refreshId: string;
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly xImxEthSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly xImxEthTimestamp: string;
    /**
     * Wallet Address that signed the signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly xImxEthAddress: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshErrors
     */
    readonly cursor?: string;
}
/**
 * Request parameters for getMetadataRefreshResults operation in MetadataRefreshesApi.
 * @export
 * @interface MetadataRefreshesApiGetMetadataRefreshResultsRequest
 */
interface MetadataRefreshesApiGetMetadataRefreshResultsRequest {
    /**
     * The metadata refresh ID
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshResults
     */
    readonly refreshId: string;
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshResults
     */
    readonly xImxEthSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshResults
     */
    readonly xImxEthTimestamp: string;
    /**
     * Wallet Address that signed the signature
     * @type {string}
     * @memberof MetadataRefreshesApiGetMetadataRefreshResults
     */
    readonly xImxEthAddress: string;
}
/**
 * Request parameters for requestAMetadataRefresh operation in MetadataRefreshesApi.
 * @export
 * @interface MetadataRefreshesApiRequestAMetadataRefreshRequest
 */
interface MetadataRefreshesApiRequestAMetadataRefreshRequest {
    /**
     * String created by signing wallet address and timestamp. See https://docs.x.immutable.com/docs/generate-imx-signature
     * @type {string}
     * @memberof MetadataRefreshesApiRequestAMetadataRefresh
     */
    readonly xImxEthSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof MetadataRefreshesApiRequestAMetadataRefresh
     */
    readonly xImxEthTimestamp: string;
    /**
     * Wallet Address that signed the signature
     * @type {string}
     * @memberof MetadataRefreshesApiRequestAMetadataRefresh
     */
    readonly xImxEthAddress: string;
    /**
     * Create metadata refresh request
     * @type {CreateMetadataRefreshRequest}
     * @memberof MetadataRefreshesApiRequestAMetadataRefresh
     */
    readonly createMetadataRefreshRequest: CreateMetadataRefreshRequest;
}
/**
 * MetadataRefreshesApi - object-oriented interface
 * @export
 * @class MetadataRefreshesApi
 * @extends {BaseAPI}
 */
declare class MetadataRefreshesApi extends BaseAPI {
    /**
     * Get a list of metadata refreshes
     * @param {MetadataRefreshesApiGetAListOfMetadataRefreshesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRefreshesApi
     */
    getAListOfMetadataRefreshes(requestParameters: MetadataRefreshesApiGetAListOfMetadataRefreshesRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMetadataRefreshes, any>>;
    /**
     * Get metadata refresh errors
     * @param {MetadataRefreshesApiGetMetadataRefreshErrorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRefreshesApi
     */
    getMetadataRefreshErrors(requestParameters: MetadataRefreshesApiGetMetadataRefreshErrorsRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMetadataRefreshErrorsResponse, any>>;
    /**
     * Get metadata refresh results
     * @param {MetadataRefreshesApiGetMetadataRefreshResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRefreshesApi
     */
    getMetadataRefreshResults(requestParameters: MetadataRefreshesApiGetMetadataRefreshResultsRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMetadataRefreshResponse, any>>;
    /**
     * Request metadata refresh for provided tokens
     * @param {MetadataRefreshesApiRequestAMetadataRefreshRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRefreshesApi
     */
    requestAMetadataRefresh(requestParameters: MetadataRefreshesApiRequestAMetadataRefreshRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateMetadataRefreshResponse, any>>;
}

/**
 * MintsApi - axios parameter creator
 * @export
 */
declare const MintsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get details of a mint with the given ID
     * @summary Get details of a mint with the given ID
     * @param {string} id Mint ID. This is the transaction_id returned from listMints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMint: (id: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get details of a mintable token with the given token address and token ID
     * @summary Get details of a mintable token with the given token address and token ID
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId ERC721 token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMintableTokenDetailsByClientTokenId: (tokenAddress: string, tokenId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get information about token mints. If you want to get information about tokens that have already been minted, use the listAssets endpoint.
     * @summary Get a list of mints
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'transaction_id' | 'token_id' | 'created_at' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this mint
     * @param {string} [status] Status of this mint
     * @param {string} [minTimestamp] Minimum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the minted asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [tokenName] Token Name of the minted asset
     * @param {string} [tokenAddress] Token address of the minted asset
     * @param {string} [minQuantity] Min quantity for the minted asset
     * @param {string} [maxQuantity] Max quantity for the minted asset
     * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMints: (pageSize?: number, cursor?: string, orderBy?: 'transaction_id' | 'token_id' | 'created_at' | 'updated_at', direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Mint tokens in a batch with fees
     * @summary Mint Tokens V2
     * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTokens: (mintTokensRequestV2: Array<MintRequest>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MintsApi - functional programming interface
 * @export
 */
declare const MintsApiFp: (configuration?: Configuration) => {
    /**
     * Get details of a mint with the given ID
     * @summary Get details of a mint with the given ID
     * @param {string} id Mint ID. This is the transaction_id returned from listMints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMint(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mint>>;
    /**
     * Get details of a mintable token with the given token address and token ID
     * @summary Get details of a mintable token with the given token address and token ID
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId ERC721 token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMintableTokenDetailsByClientTokenId(tokenAddress: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MintableTokenDetails>>;
    /**
     * Get information about token mints. If you want to get information about tokens that have already been minted, use the listAssets endpoint.
     * @summary Get a list of mints
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'transaction_id' | 'token_id' | 'created_at' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this mint
     * @param {string} [status] Status of this mint
     * @param {string} [minTimestamp] Minimum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the minted asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [tokenName] Token Name of the minted asset
     * @param {string} [tokenAddress] Token address of the minted asset
     * @param {string} [minQuantity] Min quantity for the minted asset
     * @param {string} [maxQuantity] Max quantity for the minted asset
     * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMints(pageSize?: number, cursor?: string, orderBy?: 'transaction_id' | 'token_id' | 'created_at' | 'updated_at', direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMintsResponse>>;
    /**
     * Mint tokens in a batch with fees
     * @summary Mint Tokens V2
     * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTokens(mintTokensRequestV2: Array<MintRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MintTokensResponse>>;
};
/**
 * MintsApi - factory interface
 * @export
 */
declare const MintsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get details of a mint with the given ID
     * @summary Get details of a mint with the given ID
     * @param {string} id Mint ID. This is the transaction_id returned from listMints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMint(id: string, options?: any): AxiosPromise<Mint>;
    /**
     * Get details of a mintable token with the given token address and token ID
     * @summary Get details of a mintable token with the given token address and token ID
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId ERC721 token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMintableTokenDetailsByClientTokenId(tokenAddress: string, tokenId: string, options?: any): AxiosPromise<MintableTokenDetails>;
    /**
     * Get information about token mints. If you want to get information about tokens that have already been minted, use the listAssets endpoint.
     * @summary Get a list of mints
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'transaction_id' | 'token_id' | 'created_at' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this mint
     * @param {string} [status] Status of this mint
     * @param {string} [minTimestamp] Minimum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the minted asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [tokenName] Token Name of the minted asset
     * @param {string} [tokenAddress] Token address of the minted asset
     * @param {string} [minQuantity] Min quantity for the minted asset
     * @param {string} [maxQuantity] Max quantity for the minted asset
     * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMints(pageSize?: number, cursor?: string, orderBy?: 'transaction_id' | 'token_id' | 'created_at' | 'updated_at', direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListMintsResponse>;
    /**
     * Mint tokens in a batch with fees
     * @summary Mint Tokens V2
     * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTokens(mintTokensRequestV2: Array<MintRequest>, options?: any): AxiosPromise<MintTokensResponse>;
};
/**
 * Request parameters for getMint operation in MintsApi.
 * @export
 * @interface MintsApiGetMintRequest
 */
interface MintsApiGetMintRequest {
    /**
     * Mint ID. This is the transaction_id returned from listMints
     * @type {string}
     * @memberof MintsApiGetMint
     */
    readonly id: string;
}
/**
 * Request parameters for getMintableTokenDetailsByClientTokenId operation in MintsApi.
 * @export
 * @interface MintsApiGetMintableTokenDetailsByClientTokenIdRequest
 */
interface MintsApiGetMintableTokenDetailsByClientTokenIdRequest {
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof MintsApiGetMintableTokenDetailsByClientTokenId
     */
    readonly tokenAddress: string;
    /**
     * ERC721 token ID
     * @type {string}
     * @memberof MintsApiGetMintableTokenDetailsByClientTokenId
     */
    readonly tokenId: string;
}
/**
 * Request parameters for listMints operation in MintsApi.
 * @export
 * @interface MintsApiListMintsRequest
 */
interface MintsApiListMintsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof MintsApiListMints
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'transaction_id' | 'token_id' | 'created_at' | 'updated_at'}
     * @memberof MintsApiListMints
     */
    readonly orderBy?: 'transaction_id' | 'token_id' | 'created_at' | 'updated_at';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this mint
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly user?: string;
    /**
     * Status of this mint
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly status?: string;
    /**
     * Minimum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this mint, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly maxTimestamp?: string;
    /**
     * Token type of the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly tokenType?: string;
    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly tokenId?: string;
    /**
     * Token Name of the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly tokenName?: string;
    /**
     * Token address of the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly tokenAddress?: string;
    /**
     * Min quantity for the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly minQuantity?: string;
    /**
     * Max quantity for the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly maxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the minted asset
     * @type {string}
     * @memberof MintsApiListMints
     */
    readonly metadata?: string;
}
/**
 * Request parameters for mintTokens operation in MintsApi.
 * @export
 * @interface MintsApiMintTokensRequest
 */
interface MintsApiMintTokensRequest {
    /**
     * details of tokens to mint
     * @type {Array<MintRequest>}
     * @memberof MintsApiMintTokens
     */
    readonly mintTokensRequestV2: Array<MintRequest>;
}
/**
 * MintsApi - object-oriented interface
 * @export
 * @class MintsApi
 * @extends {BaseAPI}
 */
declare class MintsApi extends BaseAPI {
    /**
     * Get details of a mint with the given ID
     * @summary Get details of a mint with the given ID
     * @param {MintsApiGetMintRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    getMint(requestParameters: MintsApiGetMintRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Mint, any>>;
    /**
     * Get details of a mintable token with the given token address and token ID
     * @summary Get details of a mintable token with the given token address and token ID
     * @param {MintsApiGetMintableTokenDetailsByClientTokenIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    getMintableTokenDetailsByClientTokenId(requestParameters: MintsApiGetMintableTokenDetailsByClientTokenIdRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<MintableTokenDetails, any>>;
    /**
     * Get information about token mints. If you want to get information about tokens that have already been minted, use the listAssets endpoint.
     * @summary Get a list of mints
     * @param {MintsApiListMintsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    listMints(requestParameters?: MintsApiListMintsRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListMintsResponse, any>>;
    /**
     * Mint tokens in a batch with fees
     * @summary Mint Tokens V2
     * @param {MintsApiMintTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintsApi
     */
    mintTokens(requestParameters: MintsApiMintTokensRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<MintTokensResponse, any>>;
}

/**
 * NftCheckoutPrimaryApi - axios parameter creator
 * @export
 */
declare const NftCheckoutPrimaryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates a transaction representing minting an NFT with a card payment.
     * @summary Create NFT primary sale transaction
     * @param {NftprimarytransactionCreateAPIRequest} createAPIRequest req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNftPrimary: (createAPIRequest: NftprimarytransactionCreateAPIRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of supported currencies and their limits
     * @summary Get currencies with limits
     * @param {'moonpay'} [provider] Provider name
     * @param {boolean} [includeLimits] Flag if limits should be included in the response or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrenciesNFTCheckoutPrimary: (provider?: 'moonpay', includeLimits?: boolean, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * given a transaction id, returns the corresponding transaction representing a mint executed from a card payment
     * @summary Get NFT primary sale transaction by id
     * @param {string} transactionId Transaction id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftPrimaryTransaction: (transactionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of NFT primary sales transactions
     * @summary Get a list of NFT primary sales transactions
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'transaction_id' | 'status' | 'amount' | 'mint_id'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [transactionId] Transaction id
     * @param {string} [contractAddress] Contract address of the asset
     * @param {string} [sellerWalletAddress] Ethereum address of the seller
     * @param {string} [userWalletAddress] Ethereum address of the user who wants to create transaction
     * @param {'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed'} [status] Transaction status
     * @param {'moonpay'} [provider] Checkout provider name
     * @param {string} [mintId] Minting transaction ID - see mintTokens response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftPrimaryTransactions: (pageSize?: number, cursor?: string, orderBy?: 'transaction_id' | 'status' | 'amount' | 'mint_id', direction?: string, transactionId?: string, contractAddress?: string, sellerWalletAddress?: string, userWalletAddress?: string, status?: 'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed', provider?: 'moonpay', mintId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Registers a new contract for use in the minting with fiat card flow
     * @summary Executes NFT primary sales contract registration
     * @param {ContractCreateAPIRequest} createAPIRequest req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerNftPrimarySalesContract: (createAPIRequest: ContractCreateAPIRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * NftCheckoutPrimaryApi - functional programming interface
 * @export
 */
declare const NftCheckoutPrimaryApiFp: (configuration?: Configuration) => {
    /**
     * Creates a transaction representing minting an NFT with a card payment.
     * @summary Create NFT primary sale transaction
     * @param {NftprimarytransactionCreateAPIRequest} createAPIRequest req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNftPrimary(createAPIRequest: NftprimarytransactionCreateAPIRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftprimarytransactionCreateResponse>>;
    /**
     * Returns a list of supported currencies and their limits
     * @summary Get currencies with limits
     * @param {'moonpay'} [provider] Provider name
     * @param {boolean} [includeLimits] Flag if limits should be included in the response or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrenciesNFTCheckoutPrimary(provider?: 'moonpay', includeLimits?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyWithLimits>>;
    /**
     * given a transaction id, returns the corresponding transaction representing a mint executed from a card payment
     * @summary Get NFT primary sale transaction by id
     * @param {string} transactionId Transaction id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftPrimaryTransaction(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftprimarytransactionGetResponse>>;
    /**
     * Returns a list of NFT primary sales transactions
     * @summary Get a list of NFT primary sales transactions
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'transaction_id' | 'status' | 'amount' | 'mint_id'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [transactionId] Transaction id
     * @param {string} [contractAddress] Contract address of the asset
     * @param {string} [sellerWalletAddress] Ethereum address of the seller
     * @param {string} [userWalletAddress] Ethereum address of the user who wants to create transaction
     * @param {'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed'} [status] Transaction status
     * @param {'moonpay'} [provider] Checkout provider name
     * @param {string} [mintId] Minting transaction ID - see mintTokens response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftPrimaryTransactions(pageSize?: number, cursor?: string, orderBy?: 'transaction_id' | 'status' | 'amount' | 'mint_id', direction?: string, transactionId?: string, contractAddress?: string, sellerWalletAddress?: string, userWalletAddress?: string, status?: 'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed', provider?: 'moonpay', mintId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftprimarytransactionListTransactionsResponse>>;
    /**
     * Registers a new contract for use in the minting with fiat card flow
     * @summary Executes NFT primary sales contract registration
     * @param {ContractCreateAPIRequest} createAPIRequest req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerNftPrimarySalesContract(createAPIRequest: ContractCreateAPIRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractCreateResponse>>;
};
/**
 * NftCheckoutPrimaryApi - factory interface
 * @export
 */
declare const NftCheckoutPrimaryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates a transaction representing minting an NFT with a card payment.
     * @summary Create NFT primary sale transaction
     * @param {NftprimarytransactionCreateAPIRequest} createAPIRequest req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNftPrimary(createAPIRequest: NftprimarytransactionCreateAPIRequest, options?: any): AxiosPromise<NftprimarytransactionCreateResponse>;
    /**
     * Returns a list of supported currencies and their limits
     * @summary Get currencies with limits
     * @param {'moonpay'} [provider] Provider name
     * @param {boolean} [includeLimits] Flag if limits should be included in the response or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrenciesNFTCheckoutPrimary(provider?: 'moonpay', includeLimits?: boolean, options?: any): AxiosPromise<CurrencyWithLimits>;
    /**
     * given a transaction id, returns the corresponding transaction representing a mint executed from a card payment
     * @summary Get NFT primary sale transaction by id
     * @param {string} transactionId Transaction id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftPrimaryTransaction(transactionId: string, options?: any): AxiosPromise<NftprimarytransactionGetResponse>;
    /**
     * Returns a list of NFT primary sales transactions
     * @summary Get a list of NFT primary sales transactions
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'transaction_id' | 'status' | 'amount' | 'mint_id'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [transactionId] Transaction id
     * @param {string} [contractAddress] Contract address of the asset
     * @param {string} [sellerWalletAddress] Ethereum address of the seller
     * @param {string} [userWalletAddress] Ethereum address of the user who wants to create transaction
     * @param {'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed'} [status] Transaction status
     * @param {'moonpay'} [provider] Checkout provider name
     * @param {string} [mintId] Minting transaction ID - see mintTokens response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftPrimaryTransactions(pageSize?: number, cursor?: string, orderBy?: 'transaction_id' | 'status' | 'amount' | 'mint_id', direction?: string, transactionId?: string, contractAddress?: string, sellerWalletAddress?: string, userWalletAddress?: string, status?: 'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed', provider?: 'moonpay', mintId?: string, options?: any): AxiosPromise<NftprimarytransactionListTransactionsResponse>;
    /**
     * Registers a new contract for use in the minting with fiat card flow
     * @summary Executes NFT primary sales contract registration
     * @param {ContractCreateAPIRequest} createAPIRequest req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerNftPrimarySalesContract(createAPIRequest: ContractCreateAPIRequest, options?: any): AxiosPromise<ContractCreateResponse>;
};
/**
 * Request parameters for createNftPrimary operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiCreateNftPrimaryRequest
 */
interface NftCheckoutPrimaryApiCreateNftPrimaryRequest {
    /**
     * req
     * @type {NftprimarytransactionCreateAPIRequest}
     * @memberof NftCheckoutPrimaryApiCreateNftPrimary
     */
    readonly createAPIRequest: NftprimarytransactionCreateAPIRequest;
}
/**
 * Request parameters for getCurrenciesNFTCheckoutPrimary operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest
 */
interface NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest {
    /**
     * Provider name
     * @type {'moonpay'}
     * @memberof NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimary
     */
    readonly provider?: 'moonpay';
    /**
     * Flag if limits should be included in the response or not
     * @type {boolean}
     * @memberof NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimary
     */
    readonly includeLimits?: boolean;
}
/**
 * Request parameters for getNftPrimaryTransaction operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest
 */
interface NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest {
    /**
     * Transaction id
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransaction
     */
    readonly transactionId: string;
}
/**
 * Request parameters for getNftPrimaryTransactions operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest
 */
interface NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'transaction_id' | 'status' | 'amount' | 'mint_id'}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly orderBy?: 'transaction_id' | 'status' | 'amount' | 'mint_id';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly direction?: string;
    /**
     * Transaction id
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly transactionId?: string;
    /**
     * Contract address of the asset
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly contractAddress?: string;
    /**
     * Ethereum address of the seller
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly sellerWalletAddress?: string;
    /**
     * Ethereum address of the user who wants to create transaction
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly userWalletAddress?: string;
    /**
     * Transaction status
     * @type {'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed'}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly status?: 'created' | 'waitingPayment' | 'pending' | 'completed' | 'failed';
    /**
     * Checkout provider name
     * @type {'moonpay'}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly provider?: 'moonpay';
    /**
     * Minting transaction ID - see mintTokens response
     * @type {string}
     * @memberof NftCheckoutPrimaryApiGetNftPrimaryTransactions
     */
    readonly mintId?: string;
}
/**
 * Request parameters for registerNftPrimarySalesContract operation in NftCheckoutPrimaryApi.
 * @export
 * @interface NftCheckoutPrimaryApiRegisterNftPrimarySalesContractRequest
 */
interface NftCheckoutPrimaryApiRegisterNftPrimarySalesContractRequest {
    /**
     * req
     * @type {ContractCreateAPIRequest}
     * @memberof NftCheckoutPrimaryApiRegisterNftPrimarySalesContract
     */
    readonly createAPIRequest: ContractCreateAPIRequest;
}
/**
 * NftCheckoutPrimaryApi - object-oriented interface
 * @export
 * @class NftCheckoutPrimaryApi
 * @extends {BaseAPI}
 */
declare class NftCheckoutPrimaryApi extends BaseAPI {
    /**
     * Creates a transaction representing minting an NFT with a card payment.
     * @summary Create NFT primary sale transaction
     * @param {NftCheckoutPrimaryApiCreateNftPrimaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    createNftPrimary(requestParameters: NftCheckoutPrimaryApiCreateNftPrimaryRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<NftprimarytransactionCreateResponse, any>>;
    /**
     * Returns a list of supported currencies and their limits
     * @summary Get currencies with limits
     * @param {NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    getCurrenciesNFTCheckoutPrimary(requestParameters?: NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CurrencyWithLimits, any>>;
    /**
     * given a transaction id, returns the corresponding transaction representing a mint executed from a card payment
     * @summary Get NFT primary sale transaction by id
     * @param {NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    getNftPrimaryTransaction(requestParameters: NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<NftprimarytransactionGetResponse, any>>;
    /**
     * Returns a list of NFT primary sales transactions
     * @summary Get a list of NFT primary sales transactions
     * @param {NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    getNftPrimaryTransactions(requestParameters?: NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<NftprimarytransactionListTransactionsResponse, any>>;
    /**
     * Registers a new contract for use in the minting with fiat card flow
     * @summary Executes NFT primary sales contract registration
     * @param {NftCheckoutPrimaryApiRegisterNftPrimarySalesContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftCheckoutPrimaryApi
     */
    registerNftPrimarySalesContract(requestParameters: NftCheckoutPrimaryApiRegisterNftPrimarySalesContractRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ContractCreateResponse, any>>;
}

/**
 * OrdersApi - axios parameter creator
 * @export
 */
declare const OrdersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Cancel an order
     * @summary Cancel an order
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {string} id Order ID to cancel
     * @param {CancelOrderRequest} cancelOrderRequest cancel an order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOrder: (xImxEthAddress: string, xImxEthSignature: string, id: string, cancelOrderRequest: CancelOrderRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create an order
     * @summary Create an order
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateOrderRequest} createOrderRequest create an order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrder: (xImxEthAddress: string, xImxEthSignature: string, createOrderRequest: CreateOrderRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get details of an order with the given ID
     * @summary Get details of an order with the given ID
     * @param {string} id Order ID
     * @param {boolean} [includeFees] Set flag to true to include fee body for the order
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder: (id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get details a signable cancel order
     * @summary Get details a signable cancel order
     * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableCancelOrder: (getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a signable order request (V3)
     * @summary Get a signable order request (V3)
     * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableOrder: (getSignableOrderRequestV3: GetSignableOrderRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of orders
     * @summary Get a list of orders
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this order
     * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
     * @param {string} [minTimestamp] Minimum created at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum created at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [buyTokenType] Token type of the asset this order buys
     * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
     * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
     * @param {string} [buyTokenAddress] Token address of the asset this order buys
     * @param {string} [buyTokenName] Token name of the asset this order buys
     * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
     * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
     * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
     * @param {string} [sellTokenType] Token type of the asset this order sells
     * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
     * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
     * @param {string} [sellTokenAddress] Token address of the asset this order sells
     * @param {string} [sellTokenName] Token name of the asset this order sells
     * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
     * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
     * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {boolean} [includeFees] Set flag to true to include fee object for orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrders: (pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, includeFees?: boolean, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * OrdersApi - functional programming interface
 * @export
 */
declare const OrdersApiFp: (configuration?: Configuration) => {
    /**
     * Cancel an order
     * @summary Cancel an order
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {string} id Order ID to cancel
     * @param {CancelOrderRequest} cancelOrderRequest cancel an order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOrder(xImxEthAddress: string, xImxEthSignature: string, id: string, cancelOrderRequest: CancelOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelOrderResponse>>;
    /**
     * Create an order
     * @summary Create an order
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateOrderRequest} createOrderRequest create an order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrder(xImxEthAddress: string, xImxEthSignature: string, createOrderRequest: CreateOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderResponse>>;
    /**
     * Get details of an order with the given ID
     * @summary Get details of an order with the given ID
     * @param {string} id Order ID
     * @param {boolean} [includeFees] Set flag to true to include fee body for the order
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>>;
    /**
     * Get details a signable cancel order
     * @summary Get details a signable cancel order
     * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableCancelOrder(getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableCancelOrderResponse>>;
    /**
     * Get a signable order request (V3)
     * @summary Get a signable order request (V3)
     * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableOrder(getSignableOrderRequestV3: GetSignableOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableOrderResponse>>;
    /**
     * Get a list of orders
     * @summary Get a list of orders
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this order
     * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
     * @param {string} [minTimestamp] Minimum created at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum created at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [buyTokenType] Token type of the asset this order buys
     * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
     * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
     * @param {string} [buyTokenAddress] Token address of the asset this order buys
     * @param {string} [buyTokenName] Token name of the asset this order buys
     * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
     * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
     * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
     * @param {string} [sellTokenType] Token type of the asset this order sells
     * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
     * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
     * @param {string} [sellTokenAddress] Token address of the asset this order sells
     * @param {string} [sellTokenName] Token name of the asset this order sells
     * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
     * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
     * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {boolean} [includeFees] Set flag to true to include fee object for orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrders(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, includeFees?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrdersResponse>>;
};
/**
 * OrdersApi - factory interface
 * @export
 */
declare const OrdersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Cancel an order
     * @summary Cancel an order
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {string} id Order ID to cancel
     * @param {CancelOrderRequest} cancelOrderRequest cancel an order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOrder(xImxEthAddress: string, xImxEthSignature: string, id: string, cancelOrderRequest: CancelOrderRequest, options?: any): AxiosPromise<CancelOrderResponse>;
    /**
     * Create an order
     * @summary Create an order
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateOrderRequest} createOrderRequest create an order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrder(xImxEthAddress: string, xImxEthSignature: string, createOrderRequest: CreateOrderRequest, options?: any): AxiosPromise<CreateOrderResponse>;
    /**
     * Get details of an order with the given ID
     * @summary Get details of an order with the given ID
     * @param {string} id Order ID
     * @param {boolean} [includeFees] Set flag to true to include fee body for the order
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<Order>;
    /**
     * Get details a signable cancel order
     * @summary Get details a signable cancel order
     * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableCancelOrder(getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options?: any): AxiosPromise<GetSignableCancelOrderResponse>;
    /**
     * Get a signable order request (V3)
     * @summary Get a signable order request (V3)
     * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableOrder(getSignableOrderRequestV3: GetSignableOrderRequest, options?: any): AxiosPromise<GetSignableOrderResponse>;
    /**
     * Get a list of orders
     * @summary Get a list of orders
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this order
     * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
     * @param {string} [minTimestamp] Minimum created at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum created at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [buyTokenType] Token type of the asset this order buys
     * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
     * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
     * @param {string} [buyTokenAddress] Token address of the asset this order buys
     * @param {string} [buyTokenName] Token name of the asset this order buys
     * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
     * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
     * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
     * @param {string} [sellTokenType] Token type of the asset this order sells
     * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
     * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
     * @param {string} [sellTokenAddress] Token address of the asset this order sells
     * @param {string} [sellTokenName] Token name of the asset this order sells
     * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
     * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
     * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {boolean} [includeFees] Set flag to true to include fee object for orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrders(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, includeFees?: boolean, options?: any): AxiosPromise<ListOrdersResponse>;
};
/**
 * Request parameters for cancelOrder operation in OrdersApi.
 * @export
 * @interface OrdersApiCancelOrderRequest
 */
interface OrdersApiCancelOrderRequest {
    /**
     * eth address
     * @type {string}
     * @memberof OrdersApiCancelOrder
     */
    readonly xImxEthAddress: string;
    /**
     * eth signature
     * @type {string}
     * @memberof OrdersApiCancelOrder
     */
    readonly xImxEthSignature: string;
    /**
     * Order ID to cancel
     * @type {string}
     * @memberof OrdersApiCancelOrder
     */
    readonly id: string;
    /**
     * cancel an order
     * @type {CancelOrderRequest}
     * @memberof OrdersApiCancelOrder
     */
    readonly cancelOrderRequest: CancelOrderRequest;
}
/**
 * Request parameters for createOrder operation in OrdersApi.
 * @export
 * @interface OrdersApiCreateOrderRequest
 */
interface OrdersApiCreateOrderRequest {
    /**
     * eth address
     * @type {string}
     * @memberof OrdersApiCreateOrder
     */
    readonly xImxEthAddress: string;
    /**
     * eth signature
     * @type {string}
     * @memberof OrdersApiCreateOrder
     */
    readonly xImxEthSignature: string;
    /**
     * create an order
     * @type {CreateOrderRequest}
     * @memberof OrdersApiCreateOrder
     */
    readonly createOrderRequest: CreateOrderRequest;
}
/**
 * Request parameters for getOrder operation in OrdersApi.
 * @export
 * @interface OrdersApiGetOrderRequest
 */
interface OrdersApiGetOrderRequest {
    /**
     * Order ID
     * @type {string}
     * @memberof OrdersApiGetOrder
     */
    readonly id: string;
    /**
     * Set flag to true to include fee body for the order
     * @type {boolean}
     * @memberof OrdersApiGetOrder
     */
    readonly includeFees?: boolean;
    /**
     * Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @type {string}
     * @memberof OrdersApiGetOrder
     */
    readonly auxiliaryFeePercentages?: string;
    /**
     * Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @type {string}
     * @memberof OrdersApiGetOrder
     */
    readonly auxiliaryFeeRecipients?: string;
}
/**
 * Request parameters for getSignableCancelOrder operation in OrdersApi.
 * @export
 * @interface OrdersApiGetSignableCancelOrderRequest
 */
interface OrdersApiGetSignableCancelOrderRequest {
    /**
     * get a signable cancel order
     * @type {GetSignableCancelOrderRequest}
     * @memberof OrdersApiGetSignableCancelOrder
     */
    readonly getSignableCancelOrderRequest: GetSignableCancelOrderRequest;
}
/**
 * Request parameters for getSignableOrder operation in OrdersApi.
 * @export
 * @interface OrdersApiGetSignableOrderRequest
 */
interface OrdersApiGetSignableOrderRequest {
    /**
     * get a signable order
     * @type {GetSignableOrderRequest}
     * @memberof OrdersApiGetSignableOrder
     */
    readonly getSignableOrderRequestV3: GetSignableOrderRequest;
}
/**
 * Request parameters for listOrders operation in OrdersApi.
 * @export
 * @interface OrdersApiListOrdersRequest
 */
interface OrdersApiListOrdersRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof OrdersApiListOrders
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at'}
     * @memberof OrdersApiListOrders
     */
    readonly orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'buy_quantity_with_fees' | 'updated_at';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this order
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly user?: string;
    /**
     * Status of this order
     * @type {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'}
     * @memberof OrdersApiListOrders
     */
    readonly status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive';
    /**
     * Minimum created at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly minTimestamp?: string;
    /**
     * Maximum created at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly maxTimestamp?: string;
    /**
     * Minimum updated at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly updatedMinTimestamp?: string;
    /**
     * Maximum updated at timestamp for this order, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly updatedMaxTimestamp?: string;
    /**
     * Token type of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly buyTokenType?: string;
    /**
     * ERC721 Token ID of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly buyTokenId?: string;
    /**
     * Internal IMX ID of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly buyAssetId?: string;
    /**
     * Token address of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly buyTokenAddress?: string;
    /**
     * Token name of the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly buyTokenName?: string;
    /**
     * Min quantity for the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly buyMinQuantity?: string;
    /**
     * Max quantity for the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly buyMaxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the asset this order buys
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly buyMetadata?: string;
    /**
     * Token type of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly sellTokenType?: string;
    /**
     * ERC721 Token ID of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly sellTokenId?: string;
    /**
     * Internal IMX ID of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly sellAssetId?: string;
    /**
     * Token address of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly sellTokenAddress?: string;
    /**
     * Token name of the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly sellTokenName?: string;
    /**
     * Min quantity for the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly sellMinQuantity?: string;
    /**
     * Max quantity for the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly sellMaxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the asset this order sells
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly sellMetadata?: string;
    /**
     * Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly auxiliaryFeePercentages?: string;
    /**
     * Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @type {string}
     * @memberof OrdersApiListOrders
     */
    readonly auxiliaryFeeRecipients?: string;
    /**
     * Set flag to true to include fee object for orders
     * @type {boolean}
     * @memberof OrdersApiListOrders
     */
    readonly includeFees?: boolean;
}
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
declare class OrdersApi extends BaseAPI {
    /**
     * Cancel an order
     * @summary Cancel an order
     * @param {OrdersApiCancelOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    cancelOrder(requestParameters: OrdersApiCancelOrderRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CancelOrderResponse, any>>;
    /**
     * Create an order
     * @summary Create an order
     * @param {OrdersApiCreateOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    createOrder(requestParameters: OrdersApiCreateOrderRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateOrderResponse, any>>;
    /**
     * Get details of an order with the given ID
     * @summary Get details of an order with the given ID
     * @param {OrdersApiGetOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrder(requestParameters: OrdersApiGetOrderRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Order, any>>;
    /**
     * Get details a signable cancel order
     * @summary Get details a signable cancel order
     * @param {OrdersApiGetSignableCancelOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getSignableCancelOrder(requestParameters: OrdersApiGetSignableCancelOrderRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableCancelOrderResponse, any>>;
    /**
     * Get a signable order request (V3)
     * @summary Get a signable order request (V3)
     * @param {OrdersApiGetSignableOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getSignableOrder(requestParameters: OrdersApiGetSignableOrderRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableOrderResponse, any>>;
    /**
     * Get a list of orders
     * @summary Get a list of orders
     * @param {OrdersApiListOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listOrders(requestParameters?: OrdersApiListOrdersRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListOrdersResponse, any>>;
}

/**
 * ProjectsApi - axios parameter creator
 * @export
 */
declare const ProjectsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a project
     * @summary Create a project
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {CreateProjectRequest} createProjectRequest create a project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject: (iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a project
     * @summary Get a project
     * @param {string} id Project ID
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject: (id: string, iMXSignature: string, iMXTimestamp: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get projects
     * @summary Get projects
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects: (iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectsApi - functional programming interface
 * @export
 */
declare const ProjectsApiFp: (configuration?: Configuration) => {
    /**
     * Create a project
     * @summary Create a project
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {CreateProjectRequest} createProjectRequest create a project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject(iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectResponse>>;
    /**
     * Get a project
     * @summary Get a project
     * @param {string} id Project ID
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject(id: string, iMXSignature: string, iMXTimestamp: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>>;
    /**
     * Get projects
     * @summary Get projects
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects(iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectsResponse>>;
};
/**
 * ProjectsApi - factory interface
 * @export
 */
declare const ProjectsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a project
     * @summary Create a project
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {CreateProjectRequest} createProjectRequest create a project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject(iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options?: any): AxiosPromise<CreateProjectResponse>;
    /**
     * Get a project
     * @summary Get a project
     * @param {string} id Project ID
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject(id: string, iMXSignature: string, iMXTimestamp: string, options?: any): AxiosPromise<Project>;
    /**
     * Get projects
     * @summary Get projects
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects(iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: any): AxiosPromise<GetProjectsResponse>;
};
/**
 * Request parameters for createProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiCreateProjectRequest
 */
interface ProjectsApiCreateProjectRequest {
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof ProjectsApiCreateProject
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof ProjectsApiCreateProject
     */
    readonly iMXTimestamp: string;
    /**
     * create a project
     * @type {CreateProjectRequest}
     * @memberof ProjectsApiCreateProject
     */
    readonly createProjectRequest: CreateProjectRequest;
}
/**
 * Request parameters for getProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectRequest
 */
interface ProjectsApiGetProjectRequest {
    /**
     * Project ID
     * @type {string}
     * @memberof ProjectsApiGetProject
     */
    readonly id: string;
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof ProjectsApiGetProject
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof ProjectsApiGetProject
     */
    readonly iMXTimestamp: string;
}
/**
 * Request parameters for getProjects operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectsRequest
 */
interface ProjectsApiGetProjectsRequest {
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly iMXSignature: string;
    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly iMXTimestamp: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof ProjectsApiGetProjects
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly orderBy?: string;
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly direction?: string;
}
/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
declare class ProjectsApi extends BaseAPI {
    /**
     * Create a project
     * @summary Create a project
     * @param {ProjectsApiCreateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    createProject(requestParameters: ProjectsApiCreateProjectRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateProjectResponse, any>>;
    /**
     * Get a project
     * @summary Get a project
     * @param {ProjectsApiGetProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getProject(requestParameters: ProjectsApiGetProjectRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Project, any>>;
    /**
     * Get projects
     * @summary Get projects
     * @param {ProjectsApiGetProjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getProjects(requestParameters: ProjectsApiGetProjectsRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetProjectsResponse, any>>;
}

/**
 * TokensApi - axios parameter creator
 * @export
 */
declare const TokensApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get details of a token
     * @summary Get details of a token
     * @param {string} address Token Contract Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken: (address: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of tokens
     * @summary Get a list of tokens
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'contract_address' | 'name' | 'symbol'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [address] Contract address of the token
     * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTokens: (pageSize?: number, cursor?: string, orderBy?: 'contract_address' | 'name' | 'symbol', direction?: string, address?: string, symbols?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TokensApi - functional programming interface
 * @export
 */
declare const TokensApiFp: (configuration?: Configuration) => {
    /**
     * Get details of a token
     * @summary Get details of a token
     * @param {string} address Token Contract Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDetails>>;
    /**
     * Get a list of tokens
     * @summary Get a list of tokens
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'contract_address' | 'name' | 'symbol'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [address] Contract address of the token
     * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTokens(pageSize?: number, cursor?: string, orderBy?: 'contract_address' | 'name' | 'symbol', direction?: string, address?: string, symbols?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTokensResponse>>;
};
/**
 * TokensApi - factory interface
 * @export
 */
declare const TokensApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get details of a token
     * @summary Get details of a token
     * @param {string} address Token Contract Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken(address: string, options?: any): AxiosPromise<TokenDetails>;
    /**
     * Get a list of tokens
     * @summary Get a list of tokens
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'contract_address' | 'name' | 'symbol'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [address] Contract address of the token
     * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTokens(pageSize?: number, cursor?: string, orderBy?: 'contract_address' | 'name' | 'symbol', direction?: string, address?: string, symbols?: string, options?: any): AxiosPromise<ListTokensResponse>;
};
/**
 * Request parameters for getToken operation in TokensApi.
 * @export
 * @interface TokensApiGetTokenRequest
 */
interface TokensApiGetTokenRequest {
    /**
     * Token Contract Address
     * @type {string}
     * @memberof TokensApiGetToken
     */
    readonly address: string;
}
/**
 * Request parameters for listTokens operation in TokensApi.
 * @export
 * @interface TokensApiListTokensRequest
 */
interface TokensApiListTokensRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof TokensApiListTokens
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof TokensApiListTokens
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'contract_address' | 'name' | 'symbol'}
     * @memberof TokensApiListTokens
     */
    readonly orderBy?: 'contract_address' | 'name' | 'symbol';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof TokensApiListTokens
     */
    readonly direction?: string;
    /**
     * Contract address of the token
     * @type {string}
     * @memberof TokensApiListTokens
     */
    readonly address?: string;
    /**
     * Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
     * @type {string}
     * @memberof TokensApiListTokens
     */
    readonly symbols?: string;
}
/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
declare class TokensApi extends BaseAPI {
    /**
     * Get details of a token
     * @summary Get details of a token
     * @param {TokensApiGetTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    getToken(requestParameters: TokensApiGetTokenRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<TokenDetails, any>>;
    /**
     * Get a list of tokens
     * @summary Get a list of tokens
     * @param {TokensApiListTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    listTokens(requestParameters?: TokensApiListTokensRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListTokensResponse, any>>;
}

/**
 * TradesApi - axios parameter creator
 * @export
 */
declare const TradesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a Trade
     * @summary Create a Trade between two parties
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTradeRequestV1} createTradeRequest create a trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTrade: (xImxEthAddress: string, xImxEthSignature: string, createTradeRequest: CreateTradeRequestV1, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get details a signable trade V3
     * @summary Get details a signable trade V3
     * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableTrade: (getSignableTradeRequest: GetSignableTradeRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get details of a trade with the given ID
     * @summary Get details of a trade with the given ID
     * @param {string} id Trade ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrade: (id: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of trades
     * @summary Get a list of trades
     * @param {string} [partyATokenType] Party A\&#39;s (buy order) token type of currency used to buy
     * @param {string} [partyATokenAddress] Party A\&#39;s (buy order) token address of currency used to buy
     * @param {string} [partyBTokenType] Party B\&#39;s (sell order) token type of NFT sold - always ERC721
     * @param {string} [partyBTokenAddress] Party B\&#39;s (sell order) collection address of NFT sold
     * @param {string} [partyBTokenId] Party B\&#39;s (sell order) token id of NFT sold
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [minTimestamp] Minimum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTrades: (partyATokenType?: string, partyATokenAddress?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TradesApi - functional programming interface
 * @export
 */
declare const TradesApiFp: (configuration?: Configuration) => {
    /**
     * Create a Trade
     * @summary Create a Trade between two parties
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTradeRequestV1} createTradeRequest create a trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTrade(xImxEthAddress: string, xImxEthSignature: string, createTradeRequest: CreateTradeRequestV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTradeResponse>>;
    /**
     * Get details a signable trade V3
     * @summary Get details a signable trade V3
     * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableTrade(getSignableTradeRequest: GetSignableTradeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTradeResponse>>;
    /**
     * Get details of a trade with the given ID
     * @summary Get details of a trade with the given ID
     * @param {string} id Trade ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrade(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>>;
    /**
     * Get a list of trades
     * @summary Get a list of trades
     * @param {string} [partyATokenType] Party A\&#39;s (buy order) token type of currency used to buy
     * @param {string} [partyATokenAddress] Party A\&#39;s (buy order) token address of currency used to buy
     * @param {string} [partyBTokenType] Party B\&#39;s (sell order) token type of NFT sold - always ERC721
     * @param {string} [partyBTokenAddress] Party B\&#39;s (sell order) collection address of NFT sold
     * @param {string} [partyBTokenId] Party B\&#39;s (sell order) token id of NFT sold
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [minTimestamp] Minimum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTrades(partyATokenType?: string, partyATokenAddress?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTradesResponse>>;
};
/**
 * TradesApi - factory interface
 * @export
 */
declare const TradesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a Trade
     * @summary Create a Trade between two parties
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTradeRequestV1} createTradeRequest create a trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTrade(xImxEthAddress: string, xImxEthSignature: string, createTradeRequest: CreateTradeRequestV1, options?: any): AxiosPromise<CreateTradeResponse>;
    /**
     * Get details a signable trade V3
     * @summary Get details a signable trade V3
     * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableTrade(getSignableTradeRequest: GetSignableTradeRequest, options?: any): AxiosPromise<GetSignableTradeResponse>;
    /**
     * Get details of a trade with the given ID
     * @summary Get details of a trade with the given ID
     * @param {string} id Trade ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrade(id: string, options?: any): AxiosPromise<Trade>;
    /**
     * Get a list of trades
     * @summary Get a list of trades
     * @param {string} [partyATokenType] Party A\&#39;s (buy order) token type of currency used to buy
     * @param {string} [partyATokenAddress] Party A\&#39;s (buy order) token address of currency used to buy
     * @param {string} [partyBTokenType] Party B\&#39;s (sell order) token type of NFT sold - always ERC721
     * @param {string} [partyBTokenAddress] Party B\&#39;s (sell order) collection address of NFT sold
     * @param {string} [partyBTokenId] Party B\&#39;s (sell order) token id of NFT sold
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [minTimestamp] Minimum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTrades(partyATokenType?: string, partyATokenAddress?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: any): AxiosPromise<ListTradesResponse>;
};
/**
 * Request parameters for createTrade operation in TradesApi.
 * @export
 * @interface TradesApiCreateTradeRequest
 */
interface TradesApiCreateTradeRequest {
    /**
     * eth address
     * @type {string}
     * @memberof TradesApiCreateTrade
     */
    readonly xImxEthAddress: string;
    /**
     * eth signature
     * @type {string}
     * @memberof TradesApiCreateTrade
     */
    readonly xImxEthSignature: string;
    /**
     * create a trade
     * @type {CreateTradeRequestV1}
     * @memberof TradesApiCreateTrade
     */
    readonly createTradeRequest: CreateTradeRequestV1;
}
/**
 * Request parameters for getSignableTrade operation in TradesApi.
 * @export
 * @interface TradesApiGetSignableTradeRequest
 */
interface TradesApiGetSignableTradeRequest {
    /**
     * get a signable trade
     * @type {GetSignableTradeRequest}
     * @memberof TradesApiGetSignableTrade
     */
    readonly getSignableTradeRequest: GetSignableTradeRequest;
}
/**
 * Request parameters for getTrade operation in TradesApi.
 * @export
 * @interface TradesApiGetTradeRequest
 */
interface TradesApiGetTradeRequest {
    /**
     * Trade ID
     * @type {string}
     * @memberof TradesApiGetTrade
     */
    readonly id: string;
}
/**
 * Request parameters for listTrades operation in TradesApi.
 * @export
 * @interface TradesApiListTradesRequest
 */
interface TradesApiListTradesRequest {
    /**
     * Party A\&#39;s (buy order) token type of currency used to buy
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly partyATokenType?: string;
    /**
     * Party A\&#39;s (buy order) token address of currency used to buy
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly partyATokenAddress?: string;
    /**
     * Party B\&#39;s (sell order) token type of NFT sold - always ERC721
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly partyBTokenType?: string;
    /**
     * Party B\&#39;s (sell order) collection address of NFT sold
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly partyBTokenAddress?: string;
    /**
     * Party B\&#39;s (sell order) token id of NFT sold
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly partyBTokenId?: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof TradesApiListTrades
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly orderBy?: string;
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly direction?: string;
    /**
     * Minimum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this trade, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof TradesApiListTrades
     */
    readonly maxTimestamp?: string;
}
/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
declare class TradesApi extends BaseAPI {
    /**
     * Create a Trade
     * @summary Create a Trade between two parties
     * @param {TradesApiCreateTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    createTrade(requestParameters: TradesApiCreateTradeRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateTradeResponse, any>>;
    /**
     * Get details a signable trade V3
     * @summary Get details a signable trade V3
     * @param {TradesApiGetSignableTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    getSignableTrade(requestParameters: TradesApiGetSignableTradeRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableTradeResponse, any>>;
    /**
     * Get details of a trade with the given ID
     * @summary Get details of a trade with the given ID
     * @param {TradesApiGetTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    getTrade(requestParameters: TradesApiGetTradeRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Trade, any>>;
    /**
     * Get a list of trades
     * @summary Get a list of trades
     * @param {TradesApiListTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    listTrades(requestParameters?: TradesApiListTradesRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListTradesResponse, any>>;
}

/**
 * TransfersApi - axios parameter creator
 * @export
 */
declare const TransfersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new transfer request
     * @summary Creates a transfer of multiple tokens between two parties
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer: (xImxEthAddress: string, xImxEthSignature: string, createTransferRequestV2: CreateTransferRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new transfer request
     * @summary Creates a transfer of tokens between two parties
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTransferRequestV1} createTransferRequest Create transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransferV1: (xImxEthAddress: string, xImxEthSignature: string, createTransferRequest: CreateTransferRequestV1, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Gets bulk details of a signable transfer
     * @summary Gets bulk details of a signable transfer
     * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableTransfer: (getSignableTransferRequestV2: GetSignableTransferRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Gets details of a signable transfer
     * @summary Gets details of a signable transfer
     * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableTransferV1: (getSignableTransferRequest: GetSignableTransferRequestV1, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get details of a transfer with the given ID
     * @summary Get details of a transfer with the given ID
     * @param {string} id Transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfer: (id: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of transfers
     * @summary Get a list of transfers
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'transaction_id' | 'updated_at' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this transfer
     * @param {string} [receiver] Ethereum address of the user who received this transfer
     * @param {'success' | 'failure'} [status] Status of this transfer
     * @param {string} [minTimestamp] Minimum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the transferred asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the transferred asset
     * @param {string} [tokenName] Token name of the transferred asset
     * @param {string} [minQuantity] Max quantity for the transferred asset
     * @param {string} [maxQuantity] Max quantity for the transferred asset
     * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransfers: (pageSize?: number, cursor?: string, orderBy?: 'transaction_id' | 'updated_at' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key', direction?: string, user?: string, receiver?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TransfersApi - functional programming interface
 * @export
 */
declare const TransfersApiFp: (configuration?: Configuration) => {
    /**
     * Create a new transfer request
     * @summary Creates a transfer of multiple tokens between two parties
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer(xImxEthAddress: string, xImxEthSignature: string, createTransferRequestV2: CreateTransferRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferResponse>>;
    /**
     * Create a new transfer request
     * @summary Creates a transfer of tokens between two parties
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTransferRequestV1} createTransferRequest Create transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransferV1(xImxEthAddress: string, xImxEthSignature: string, createTransferRequest: CreateTransferRequestV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferResponseV1>>;
    /**
     * Gets bulk details of a signable transfer
     * @summary Gets bulk details of a signable transfer
     * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableTransfer(getSignableTransferRequestV2: GetSignableTransferRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTransferResponse>>;
    /**
     * Gets details of a signable transfer
     * @summary Gets details of a signable transfer
     * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableTransferV1(getSignableTransferRequest: GetSignableTransferRequestV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTransferResponseV1>>;
    /**
     * Get details of a transfer with the given ID
     * @summary Get details of a transfer with the given ID
     * @param {string} id Transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>>;
    /**
     * Get a list of transfers
     * @summary Get a list of transfers
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'transaction_id' | 'updated_at' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this transfer
     * @param {string} [receiver] Ethereum address of the user who received this transfer
     * @param {'success' | 'failure'} [status] Status of this transfer
     * @param {string} [minTimestamp] Minimum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the transferred asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the transferred asset
     * @param {string} [tokenName] Token name of the transferred asset
     * @param {string} [minQuantity] Max quantity for the transferred asset
     * @param {string} [maxQuantity] Max quantity for the transferred asset
     * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransfers(pageSize?: number, cursor?: string, orderBy?: 'transaction_id' | 'updated_at' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key', direction?: string, user?: string, receiver?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransfersResponse>>;
};
/**
 * TransfersApi - factory interface
 * @export
 */
declare const TransfersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new transfer request
     * @summary Creates a transfer of multiple tokens between two parties
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer(xImxEthAddress: string, xImxEthSignature: string, createTransferRequestV2: CreateTransferRequest, options?: any): AxiosPromise<CreateTransferResponse>;
    /**
     * Create a new transfer request
     * @summary Creates a transfer of tokens between two parties
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateTransferRequestV1} createTransferRequest Create transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransferV1(xImxEthAddress: string, xImxEthSignature: string, createTransferRequest: CreateTransferRequestV1, options?: any): AxiosPromise<CreateTransferResponseV1>;
    /**
     * Gets bulk details of a signable transfer
     * @summary Gets bulk details of a signable transfer
     * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableTransfer(getSignableTransferRequestV2: GetSignableTransferRequest, options?: any): AxiosPromise<GetSignableTransferResponse>;
    /**
     * Gets details of a signable transfer
     * @summary Gets details of a signable transfer
     * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableTransferV1(getSignableTransferRequest: GetSignableTransferRequestV1, options?: any): AxiosPromise<GetSignableTransferResponseV1>;
    /**
     * Get details of a transfer with the given ID
     * @summary Get details of a transfer with the given ID
     * @param {string} id Transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfer(id: string, options?: any): AxiosPromise<Transfer>;
    /**
     * Get a list of transfers
     * @summary Get a list of transfers
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'transaction_id' | 'updated_at' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this transfer
     * @param {string} [receiver] Ethereum address of the user who received this transfer
     * @param {'success' | 'failure'} [status] Status of this transfer
     * @param {string} [minTimestamp] Minimum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the transferred asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the transferred asset
     * @param {string} [tokenName] Token name of the transferred asset
     * @param {string} [minQuantity] Max quantity for the transferred asset
     * @param {string} [maxQuantity] Max quantity for the transferred asset
     * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransfers(pageSize?: number, cursor?: string, orderBy?: 'transaction_id' | 'updated_at' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key', direction?: string, user?: string, receiver?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListTransfersResponse>;
};
/**
 * Request parameters for createTransfer operation in TransfersApi.
 * @export
 * @interface TransfersApiCreateTransferRequest
 */
interface TransfersApiCreateTransferRequest {
    /**
     * eth address
     * @type {string}
     * @memberof TransfersApiCreateTransfer
     */
    readonly xImxEthAddress: string;
    /**
     * eth signature
     * @type {string}
     * @memberof TransfersApiCreateTransfer
     */
    readonly xImxEthSignature: string;
    /**
     * Create transfer
     * @type {CreateTransferRequest}
     * @memberof TransfersApiCreateTransfer
     */
    readonly createTransferRequestV2: CreateTransferRequest;
}
/**
 * Request parameters for createTransferV1 operation in TransfersApi.
 * @export
 * @interface TransfersApiCreateTransferV1Request
 */
interface TransfersApiCreateTransferV1Request {
    /**
     * eth address
     * @type {string}
     * @memberof TransfersApiCreateTransferV1
     */
    readonly xImxEthAddress: string;
    /**
     * eth signature
     * @type {string}
     * @memberof TransfersApiCreateTransferV1
     */
    readonly xImxEthSignature: string;
    /**
     * Create transfer
     * @type {CreateTransferRequestV1}
     * @memberof TransfersApiCreateTransferV1
     */
    readonly createTransferRequest: CreateTransferRequestV1;
}
/**
 * Request parameters for getSignableTransfer operation in TransfersApi.
 * @export
 * @interface TransfersApiGetSignableTransferRequest
 */
interface TransfersApiGetSignableTransferRequest {
    /**
     * get details of signable transfer
     * @type {GetSignableTransferRequest}
     * @memberof TransfersApiGetSignableTransfer
     */
    readonly getSignableTransferRequestV2: GetSignableTransferRequest;
}
/**
 * Request parameters for getSignableTransferV1 operation in TransfersApi.
 * @export
 * @interface TransfersApiGetSignableTransferV1Request
 */
interface TransfersApiGetSignableTransferV1Request {
    /**
     * get details of signable transfer
     * @type {GetSignableTransferRequestV1}
     * @memberof TransfersApiGetSignableTransferV1
     */
    readonly getSignableTransferRequest: GetSignableTransferRequestV1;
}
/**
 * Request parameters for getTransfer operation in TransfersApi.
 * @export
 * @interface TransfersApiGetTransferRequest
 */
interface TransfersApiGetTransferRequest {
    /**
     * Transfer ID
     * @type {string}
     * @memberof TransfersApiGetTransfer
     */
    readonly id: string;
}
/**
 * Request parameters for listTransfers operation in TransfersApi.
 * @export
 * @interface TransfersApiListTransfersRequest
 */
interface TransfersApiListTransfersRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof TransfersApiListTransfers
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {'transaction_id' | 'updated_at' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key'}
     * @memberof TransfersApiListTransfers
     */
    readonly orderBy?: 'transaction_id' | 'updated_at' | 'created_at' | 'sender_ether_key' | 'receiver_ether_key';
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this transfer
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly user?: string;
    /**
     * Ethereum address of the user who received this transfer
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly receiver?: string;
    /**
     * Status of this transfer
     * @type {'success' | 'failure'}
     * @memberof TransfersApiListTransfers
     */
    readonly status?: 'success' | 'failure';
    /**
     * Minimum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this transfer, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly maxTimestamp?: string;
    /**
     * Token type of the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly tokenType?: string;
    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly tokenId?: string;
    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly assetId?: string;
    /**
     * Token address of the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly tokenAddress?: string;
    /**
     * Token name of the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly tokenName?: string;
    /**
     * Max quantity for the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly minQuantity?: string;
    /**
     * Max quantity for the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly maxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the transferred asset
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly metadata?: string;
}
/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
declare class TransfersApi extends BaseAPI {
    /**
     * Create a new transfer request
     * @summary Creates a transfer of multiple tokens between two parties
     * @param {TransfersApiCreateTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransfer(requestParameters: TransfersApiCreateTransferRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateTransferResponse, any>>;
    /**
     * Create a new transfer request
     * @summary Creates a transfer of tokens between two parties
     * @param {TransfersApiCreateTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransferV1(requestParameters: TransfersApiCreateTransferV1Request, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateTransferResponseV1, any>>;
    /**
     * Gets bulk details of a signable transfer
     * @summary Gets bulk details of a signable transfer
     * @param {TransfersApiGetSignableTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getSignableTransfer(requestParameters: TransfersApiGetSignableTransferRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableTransferResponse, any>>;
    /**
     * Gets details of a signable transfer
     * @summary Gets details of a signable transfer
     * @param {TransfersApiGetSignableTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getSignableTransferV1(requestParameters: TransfersApiGetSignableTransferV1Request, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableTransferResponseV1, any>>;
    /**
     * Get details of a transfer with the given ID
     * @summary Get details of a transfer with the given ID
     * @param {TransfersApiGetTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getTransfer(requestParameters: TransfersApiGetTransferRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Transfer, any>>;
    /**
     * Get a list of transfers
     * @summary Get a list of transfers
     * @param {TransfersApiListTransfersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    listTransfers(requestParameters?: TransfersApiListTransfersRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListTransfersResponse, any>>;
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get operator signature to allow clients to register the user
     * @summary Get operator signature to allow clients to register the user
     * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableRegistration: (getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get encoded details to allow clients to register the user offchain
     * @summary Get encoded details to allow clients to register the user offchain
     * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User Offchain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableRegistrationOffchain: (getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get stark keys for a registered user
     * @summary Get stark keys for a registered user
     * @param {string} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: (user: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Registers a user
     * @summary Registers a user
     * @param {RegisterUserRequest} registerUserRequest Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser: (registerUserRequest: RegisterUserRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 * @export
 */
declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     * Get operator signature to allow clients to register the user
     * @summary Get operator signature to allow clients to register the user
     * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableRegistration(getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableRegistrationResponse>>;
    /**
     * Get encoded details to allow clients to register the user offchain
     * @summary Get encoded details to allow clients to register the user offchain
     * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User Offchain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableRegistrationOffchain(getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableRegistrationOffchainResponse>>;
    /**
     * Get stark keys for a registered user
     * @summary Get stark keys for a registered user
     * @param {string} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersApiResponse>>;
    /**
     * Registers a user
     * @summary Registers a user
     * @param {RegisterUserRequest} registerUserRequest Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(registerUserRequest: RegisterUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUserResponse>>;
};
/**
 * UsersApi - factory interface
 * @export
 */
declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get operator signature to allow clients to register the user
     * @summary Get operator signature to allow clients to register the user
     * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableRegistration(getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: any): AxiosPromise<GetSignableRegistrationResponse>;
    /**
     * Get encoded details to allow clients to register the user offchain
     * @summary Get encoded details to allow clients to register the user offchain
     * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User Offchain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableRegistrationOffchain(getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: any): AxiosPromise<GetSignableRegistrationOffchainResponse>;
    /**
     * Get stark keys for a registered user
     * @summary Get stark keys for a registered user
     * @param {string} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(user: string, options?: any): AxiosPromise<GetUsersApiResponse>;
    /**
     * Registers a user
     * @summary Registers a user
     * @param {RegisterUserRequest} registerUserRequest Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(registerUserRequest: RegisterUserRequest, options?: any): AxiosPromise<RegisterUserResponse>;
};
/**
 * Request parameters for getSignableRegistration operation in UsersApi.
 * @export
 * @interface UsersApiGetSignableRegistrationRequest
 */
interface UsersApiGetSignableRegistrationRequest {
    /**
     * Register User
     * @type {GetSignableRegistrationRequest}
     * @memberof UsersApiGetSignableRegistration
     */
    readonly getSignableRegistrationRequest: GetSignableRegistrationRequest;
}
/**
 * Request parameters for getSignableRegistrationOffchain operation in UsersApi.
 * @export
 * @interface UsersApiGetSignableRegistrationOffchainRequest
 */
interface UsersApiGetSignableRegistrationOffchainRequest {
    /**
     * Register User Offchain
     * @type {GetSignableRegistrationRequest}
     * @memberof UsersApiGetSignableRegistrationOffchain
     */
    readonly getSignableRegistrationRequest: GetSignableRegistrationRequest;
}
/**
 * Request parameters for getUsers operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersRequest
 */
interface UsersApiGetUsersRequest {
    /**
     * User
     * @type {string}
     * @memberof UsersApiGetUsers
     */
    readonly user: string;
}
/**
 * Request parameters for registerUser operation in UsersApi.
 * @export
 * @interface UsersApiRegisterUserRequest
 */
interface UsersApiRegisterUserRequest {
    /**
     * Register User
     * @type {RegisterUserRequest}
     * @memberof UsersApiRegisterUser
     */
    readonly registerUserRequest: RegisterUserRequest;
}
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
declare class UsersApi extends BaseAPI {
    /**
     * Get operator signature to allow clients to register the user
     * @summary Get operator signature to allow clients to register the user
     * @param {UsersApiGetSignableRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getSignableRegistration(requestParameters: UsersApiGetSignableRegistrationRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableRegistrationResponse, any>>;
    /**
     * Get encoded details to allow clients to register the user offchain
     * @summary Get encoded details to allow clients to register the user offchain
     * @param {UsersApiGetSignableRegistrationOffchainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getSignableRegistrationOffchain(requestParameters: UsersApiGetSignableRegistrationOffchainRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableRegistrationOffchainResponse, any>>;
    /**
     * Get stark keys for a registered user
     * @summary Get stark keys for a registered user
     * @param {UsersApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsers(requestParameters: UsersApiGetUsersRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetUsersApiResponse, any>>;
    /**
     * Registers a user
     * @summary Registers a user
     * @param {UsersApiRegisterUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    registerUser(requestParameters: UsersApiRegisterUserRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<RegisterUserResponse, any>>;
}

/**
 * WithdrawalsApi - axios parameter creator
 * @export
 */
declare const WithdrawalsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates a withdrawal
     * @summary Creates a withdrawal of a token
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWithdrawal: (xImxEthAddress: string, xImxEthSignature: string, createWithdrawalRequest: CreateWithdrawalRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Gets details of a signable withdrawal
     * @summary Gets details of a signable withdrawal
     * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableWithdrawal: (getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Gets details of withdrawal with the given ID
     * @summary Gets details of withdrawal with the given ID
     * @param {string} id Withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWithdrawal: (id: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of withdrawals
     * @summary Get a list of withdrawals
     * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
     * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this withdrawal
     * @param {string} [status] Status of this withdrawal
     * @param {string} [minTimestamp] Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the withdrawn asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the withdrawn asset
     * @param {string} [tokenName] Token name of the withdrawn asset
     * @param {string} [minQuantity] Min quantity for the withdrawn asset
     * @param {string} [maxQuantity] Max quantity for the withdrawn asset
     * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWithdrawals: (withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WithdrawalsApi - functional programming interface
 * @export
 */
declare const WithdrawalsApiFp: (configuration?: Configuration) => {
    /**
     * Creates a withdrawal
     * @summary Creates a withdrawal of a token
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWithdrawal(xImxEthAddress: string, xImxEthSignature: string, createWithdrawalRequest: CreateWithdrawalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWithdrawalResponse>>;
    /**
     * Gets details of a signable withdrawal
     * @summary Gets details of a signable withdrawal
     * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableWithdrawal(getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableWithdrawalResponse>>;
    /**
     * Gets details of withdrawal with the given ID
     * @summary Gets details of withdrawal with the given ID
     * @param {string} id Withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWithdrawal(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Withdrawal>>;
    /**
     * Get a list of withdrawals
     * @summary Get a list of withdrawals
     * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
     * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this withdrawal
     * @param {string} [status] Status of this withdrawal
     * @param {string} [minTimestamp] Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the withdrawn asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the withdrawn asset
     * @param {string} [tokenName] Token name of the withdrawn asset
     * @param {string} [minQuantity] Min quantity for the withdrawn asset
     * @param {string} [maxQuantity] Max quantity for the withdrawn asset
     * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWithdrawals(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWithdrawalsResponse>>;
};
/**
 * WithdrawalsApi - factory interface
 * @export
 */
declare const WithdrawalsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates a withdrawal
     * @summary Creates a withdrawal of a token
     * @param {string} xImxEthAddress eth address
     * @param {string} xImxEthSignature eth signature
     * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWithdrawal(xImxEthAddress: string, xImxEthSignature: string, createWithdrawalRequest: CreateWithdrawalRequest, options?: any): AxiosPromise<CreateWithdrawalResponse>;
    /**
     * Gets details of a signable withdrawal
     * @summary Gets details of a signable withdrawal
     * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignableWithdrawal(getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options?: any): AxiosPromise<GetSignableWithdrawalResponse>;
    /**
     * Gets details of withdrawal with the given ID
     * @summary Gets details of withdrawal with the given ID
     * @param {string} id Withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWithdrawal(id: string, options?: any): AxiosPromise<Withdrawal>;
    /**
     * Get a list of withdrawals
     * @summary Get a list of withdrawals
     * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
     * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this withdrawal
     * @param {string} [status] Status of this withdrawal
     * @param {string} [minTimestamp] Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @param {string} [tokenType] Token type of the withdrawn asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the withdrawn asset
     * @param {string} [tokenName] Token name of the withdrawn asset
     * @param {string} [minQuantity] Min quantity for the withdrawn asset
     * @param {string} [maxQuantity] Max quantity for the withdrawn asset
     * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWithdrawals(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListWithdrawalsResponse>;
};
/**
 * Request parameters for createWithdrawal operation in WithdrawalsApi.
 * @export
 * @interface WithdrawalsApiCreateWithdrawalRequest
 */
interface WithdrawalsApiCreateWithdrawalRequest {
    /**
     * eth address
     * @type {string}
     * @memberof WithdrawalsApiCreateWithdrawal
     */
    readonly xImxEthAddress: string;
    /**
     * eth signature
     * @type {string}
     * @memberof WithdrawalsApiCreateWithdrawal
     */
    readonly xImxEthSignature: string;
    /**
     * create a withdrawal
     * @type {CreateWithdrawalRequest}
     * @memberof WithdrawalsApiCreateWithdrawal
     */
    readonly createWithdrawalRequest: CreateWithdrawalRequest;
}
/**
 * Request parameters for getSignableWithdrawal operation in WithdrawalsApi.
 * @export
 * @interface WithdrawalsApiGetSignableWithdrawalRequest
 */
interface WithdrawalsApiGetSignableWithdrawalRequest {
    /**
     * get details of signable withdrawal
     * @type {GetSignableWithdrawalRequest}
     * @memberof WithdrawalsApiGetSignableWithdrawal
     */
    readonly getSignableWithdrawalRequest: GetSignableWithdrawalRequest;
}
/**
 * Request parameters for getWithdrawal operation in WithdrawalsApi.
 * @export
 * @interface WithdrawalsApiGetWithdrawalRequest
 */
interface WithdrawalsApiGetWithdrawalRequest {
    /**
     * Withdrawal ID
     * @type {string}
     * @memberof WithdrawalsApiGetWithdrawal
     */
    readonly id: string;
}
/**
 * Request parameters for listWithdrawals operation in WithdrawalsApi.
 * @export
 * @interface WithdrawalsApiListWithdrawalsRequest
 */
interface WithdrawalsApiListWithdrawalsRequest {
    /**
     * Withdrawal has been transferred to user\&#39;s Layer 1 wallet
     * @type {boolean}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly withdrawnToWallet?: boolean;
    /**
     * Status of the on-chain batch confirmation for this withdrawal
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly rollupStatus?: string;
    /**
     * Page size of the result
     * @type {number}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly pageSize?: number;
    /**
     * Cursor
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly cursor?: string;
    /**
     * Property to sort by
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly orderBy?: string;
    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly direction?: string;
    /**
     * Ethereum address of the user who submitted this withdrawal
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly user?: string;
    /**
     * Status of this withdrawal
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly status?: string;
    /**
     * Minimum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly minTimestamp?: string;
    /**
     * Maximum timestamp for this deposit, in ISO 8601 UTC format. Example: \&#39;2022-05-27T00:10:22Z\&#39;
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly maxTimestamp?: string;
    /**
     * Token type of the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly tokenType?: string;
    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly tokenId?: string;
    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly assetId?: string;
    /**
     * Token address of the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly tokenAddress?: string;
    /**
     * Token name of the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly tokenName?: string;
    /**
     * Min quantity for the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly minQuantity?: string;
    /**
     * Max quantity for the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly maxQuantity?: string;
    /**
     * JSON-encoded metadata filters for the withdrawn asset
     * @type {string}
     * @memberof WithdrawalsApiListWithdrawals
     */
    readonly metadata?: string;
}
/**
 * WithdrawalsApi - object-oriented interface
 * @export
 * @class WithdrawalsApi
 * @extends {BaseAPI}
 */
declare class WithdrawalsApi extends BaseAPI {
    /**
     * Creates a withdrawal
     * @summary Creates a withdrawal of a token
     * @param {WithdrawalsApiCreateWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    createWithdrawal(requestParameters: WithdrawalsApiCreateWithdrawalRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateWithdrawalResponse, any>>;
    /**
     * Gets details of a signable withdrawal
     * @summary Gets details of a signable withdrawal
     * @param {WithdrawalsApiGetSignableWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    getSignableWithdrawal(requestParameters: WithdrawalsApiGetSignableWithdrawalRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSignableWithdrawalResponse, any>>;
    /**
     * Gets details of withdrawal with the given ID
     * @summary Gets details of withdrawal with the given ID
     * @param {WithdrawalsApiGetWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    getWithdrawal(requestParameters: WithdrawalsApiGetWithdrawalRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Withdrawal, any>>;
    /**
     * Get a list of withdrawals
     * @summary Get a list of withdrawals
     * @param {WithdrawalsApiListWithdrawalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    listWithdrawals(requestParameters?: WithdrawalsApiListWithdrawalsRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListWithdrawalsResponse, any>>;
}

/**
 * Parameter required to create an Order
 */
interface UnsignedOrderRequest {
    /**
     * The amount of tokens that will be bought for this order
     */
    buy: TokenAmount;
    /**
     * The amount of tokens that will be sold for this order
     */
    sell: TokenAmount;
    /**
     * ExpirationTimestamp in Unix time. Note: will be rounded down to the nearest hour
     */
    expiration_timestamp?: number;
    /**
     * Inclusion of either maker or taker fees
     */
    fees?: Array<FeeEntry>;
}
/**
 * Parameter required to create a Transfer
 */
declare type UnsignedTransferRequest = TokenAmount & {
    /**
     * Ethereum address of the receiving user
     */
    receiver: string;
};
/**
 * Parameter required to Mint tokens
 */
declare type UnsignedMintRequest = Omit<MintRequest, 'auth_signature'>;
/**
 * Parameter required to create a Transfer
 */
declare type UnsignedExchangeTransferRequest = ExchangeTokenAmount & {
    /**
     * Ethereum address of the receiving user
     */
    receiver: string;
    /**
     * Exchange transaction ID
     */
    transactionID: string;
};

/**
 * Parameter required to create a batchNftTransfer
 */
interface NftTransferDetails {
    /**
     * Ethereum address of the receiving user
     */
    receiver: string;
    /**
     * The token ID
     */
    tokenId: string;
    /**
     * The token contract address
     */
    tokenAddress: string;
}

/**
 * Custom Error class that is returned from the API when a request fails
 */
declare class IMXError extends Error {
    /**
     * [See a list of thrown error codes](https://docs.x.immutable.com/docs/error-codes/)
     */
    readonly code: string;
    readonly details?: string;
    constructor({ code, details, message }: APIError);
}

/**
 * Creates a new Stark Signer
 * @params starkPrivateKey - the private key as a hex string
 * @returns a StarkSigner
 */
declare function createStarkSigner(starkPrivateKey: string): StarkSigner;

/**
 * The configuration for the Ethereum network
 */
interface EthConfiguration {
    coreContractAddress: string;
    registrationContractAddress: string;
    chainID: number;
}
/**
 * The configuration for the ImmutableX client
 */
interface ImmutableXConfiguration {
    /**
     * The configuration for the API client
     */
    apiConfiguration: Configuration;
    /**
     * The configuration for the Ethereum network
     */
    ethConfiguration: EthConfiguration;
}
interface Environment extends EthConfiguration {
    basePath: string;
    headers?: Record<string, string>;
}
/**
 * Creates a Configuration for the specified environment
 * @returns an ImmutableXConfiguration
 */
declare const Config: {
    readonly PRODUCTION: ImmutableXConfiguration;
    readonly SANDBOX: ImmutableXConfiguration;
    createConfig: ({ coreContractAddress, registrationContractAddress, chainID, basePath, headers, }: Environment) => ImmutableXConfiguration;
};

/**
 * The main entry point for the Core SDK
 */
declare class ImmutableX {
    depositsApi: DepositsApi;
    mintsApi: MintsApi;
    ordersApi: OrdersApi;
    tokensApi: TokensApi;
    tradesApi: TradesApi;
    transfersApi: TransfersApi;
    exchangeApi: ExchangesApi;
    nftCheckoutPrimaryApi: NftCheckoutPrimaryApi;
    usersApi: UsersApi;
    withdrawalsApi: WithdrawalsApi;
    balanceApi: BalancesApi;
    assetApi: AssetsApi;
    collectionApi: CollectionsApi;
    metadataApi: MetadataApi;
    metadataRefreshesApi: MetadataRefreshesApi;
    projectsApi: ProjectsApi;
    private workflows;
    constructor(config: ImmutableXConfiguration);
    /**
     * Deposit based on a token type. For unregistered Users, the Deposit will be combined with a registration in order to register the User first
     * @param ethSigner - the L1 signer
     * @param deposit - the token type amount in its corresponding unit
     * @returns a promise that resolves with the resulting transaction
     * @throws {@link index.IMXError}
     */
    deposit(ethSigner: Signer$1, deposit: TokenAmount): Promise<_ethersproject_abstract_provider.TransactionResponse>;
    /**
     * Get details of a Deposit with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Deposit
     * @throws {@link index.IMXError}
     */
    getDeposit(request: DepositsApiGetDepositRequest): Promise<Deposit>;
    /**
     * Get a list of Deposits
     * @param request - optional request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Deposits
     * @throws {@link index.IMXError}
     */
    listDeposits(request?: DepositsApiListDepositsRequest): Promise<ListDepositsResponse>;
    /**
     * Register a User to Immutable X if they are not already
     * @param walletConnection - the pair of L1/L2 signers
     * @returns a promise that resolves with void if successful
     * @throws {@link index.IMXError}
     */
    registerOffchain(walletConnection: WalletConnection): Promise<RegisterUserResponse>;
    /**
     * Checks if a User is registered on on-chain
     * @param walletConnection - the pair of L1/L2 signers
     * @returns a promise that resolves with true if the User is registered, false otherwise
     * @throws {@link index.IMXError}
     */
    isRegisteredOnchain(walletConnection: WalletConnection): Promise<boolean>;
    /**
     * Get Stark keys for a registered User
     * @param ethAddress - the eth address of the User
     * @returns a promise that resolves with the requested User
     * @throws {@link index.IMXError}
     */
    getUser(ethAddress: string): Promise<GetUsersApiResponse>;
    /**
     * Get details of an Asset
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Asset
     * @throws {@link index.IMXError}
     */
    getAsset(request: AssetsApiGetAssetRequest): Promise<Asset>;
    /**
     * Get a list of Assets
     * @param request - optional request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Assets
     * @throws {@link index.IMXError}
     */
    listAssets(request?: AssetsApiListAssetsRequest): Promise<ListAssetsResponse>;
    /**
     * Create a Collection
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Collection
     * @throws {@link index.IMXError}
     */
    createCollection(ethSigner: Signer$1, request: CreateCollectionRequest): Promise<Collection>;
    /**
     * Get details of a Collection at the given address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Collection
     * @throws {@link index.IMXError}
     */
    getCollection(request: CollectionsApiGetCollectionRequest): Promise<Collection>;
    /**
     * Get a list of Collection filters
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collection Filters
     * @throws {@link index.IMXError}
     */
    listCollectionFilters(request: CollectionsApiListCollectionFiltersRequest): Promise<CollectionFilter>;
    /**
     * Get a list of Collections
     * @param request - optional request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collections
     * @throws {@link index.IMXError}
     */
    listCollections(request?: CollectionsApiListCollectionsRequest): Promise<ListCollectionsResponse>;
    /**
     * Update a Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the updated Collection
     * @throws {@link index.IMXError}
     */
    updateCollection(ethSigner: Signer$1, collectionAddress: string, request: UpdateCollectionRequest): Promise<Collection>;
    /**
     * Add metadata schema to Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    addMetadataSchemaToCollection(ethSigner: Signer$1, collectionAddress: string, request: AddMetadataSchemaToCollectionRequest): Promise<SuccessResponse>;
    /**
     * Get Metadata schema
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Metadata schema
     * @throws {@link index.IMXError}
     */
    getMetadataSchema(request: MetadataApiGetMetadataSchemaRequest): Promise<MetadataSchemaProperty[]>;
    /**
     * Update metadata schema by name
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param name - the Metadata schema name
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    updateMetadataSchemaByName(ethSigner: Signer$1, collectionAddress: string, name: string, request: MetadataSchemaRequest): Promise<SuccessResponse>;
    /**
     * Get a list of metadata refreshes
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refreshes
     * @throws {@link index.IMXError}
     */
    listMetadataRefreshes(ethSigner: Signer$1, collectionAddress?: string, pageSize?: number, cursor?: string): Promise<GetMetadataRefreshes>;
    /**
     * Get a list of metadata refresh errors
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refresh errors
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshErrors(ethSigner: Signer$1, refreshId: string, pageSize?: number, cursor?: string): Promise<GetMetadataRefreshErrorsResponse>;
    /**
     * Get a list of metadata refresh results
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @returns a promise that resolves with the requested metadata refresh results
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshResults(ethSigner: Signer$1, refreshId: string): Promise<GetMetadataRefreshResponse>;
    /**
     * Request a metadata refresh
     * @param ethSigner - the L1 signer
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested metadata refresh
     * @throws {@link index.IMXError}
     */
    createMetadataRefresh(ethSigner: Signer$1, request: CreateMetadataRefreshRequest): Promise<CreateMetadataRefreshResponse>;
    /**
     * Create a Project
     * @param ethSigner - the L1 signer
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the created Project
     * @throws {@link index.IMXError}
     */
    createProject(ethSigner: Signer$1, request: CreateProjectRequest): Promise<CreateProjectResponse>;
    /**
     * Get a Project
     * @param ethSigner - the L1 signer
     * @param id - the Project ID
     * @returns a promise that resolves with the requested Project
     * @throws {@link index.IMXError}
     */
    getProject(ethSigner: Signer$1, id: string): Promise<Project>;
    /**
     * Get Projects owned by the given User
     * @param ethSigner - the L1 signer
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @param orderBy - the property to sort by
     * @param direction - direction to sort (asc/desc)
     * @returns a promise that resolves with the requested Projects
     * @throws {@link index.IMXError}
     */
    getProjects(ethSigner: Signer$1, pageSize?: number, cursor?: string, orderBy?: string, direction?: string): Promise<GetProjectsResponse>;
    /**
     * Get the token Balances of the User
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Balance
     * @throws {@link index.IMXError}
     */
    getBalance(request: BalancesApiGetBalanceRequest): Promise<Balance>;
    /**
     * Get a list of Balances for given User
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Balances
     * @throws {@link index.IMXError}
     */
    listBalances(request: BalancesApiListBalancesRequest): Promise<ListBalancesResponse>;
    /**
     * Get details of a Mint with the given ID
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Mint
     * @throws {@link index.IMXError}
     */
    getMint(request: MintsApiGetMintRequest): Promise<Mint>;
    /**
     * Get a list of Mints
     * @param request optional request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Mints
     * @throws {@link index.IMXError}
     */
    listMints(request?: MintsApiListMintsRequest): Promise<ListMintsResponse>;
    /**
     * Mint tokens in a batch with fees
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the minted tokens
     * @throws {@link index.IMXError}
     */
    mint(ethSigner: Signer$1, request: UnsignedMintRequest): Promise<MintTokensResponse>;
    /**
     * Get a list of Withdrawals
     * @param request - optional request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Withdrawals
     * @throws {@link index.IMXError}
     */
    listWithdrawals(request?: WithdrawalsApiListWithdrawalsRequest): Promise<ListWithdrawalsResponse>;
    /**
     * Get details of Withdrawal with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Withdrawal
     * @throws {@link index.IMXError}
     */
    getWithdrawal(request: WithdrawalsApiGetWithdrawalRequest): Promise<Withdrawal>;
    /**
     * Create a Withdrawal
     * @param walletConnection - the pair of L1/L2 signers
     * @param request - the token type amount in its corresponding unit
     * @returns a promise that resolves with the created Withdrawal
     * @throws {@link index.IMXError}
     */
    prepareWithdrawal(walletConnection: WalletConnection, request: TokenAmount): Promise<CreateWithdrawalResponse>;
    /**
     * Completes a Withdrawal
     * @param ethSigner - the L1 signer
     * @param starkPublicKey - the Signer address
     * @param token - the token
     * @returns a promise that resolves with the transaction
     * @throws {@link index.IMXError}
     */
    completeWithdrawal(ethSigner: Signer$1, starkPublicKey: string, token: AnyToken): Promise<_ethersproject_abstract_provider.TransactionResponse>;
    /**
     * Get details of an Order with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Order
     * @throws {@link index.IMXError}
     */
    getOrder(request: OrdersApiGetOrderRequest): Promise<Order>;
    /**
     * Get a list of Orders
     * @param request - optional request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Orders
     * @throws {@link index.IMXError}
     */
    listOrders(request?: OrdersApiListOrdersRequest): Promise<ListOrdersResponse>;
    /**
     * Create an Order
     * @param walletConnection - the pair of L1/L2 signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Order
     * @throws {@link index.IMXError}
     */
    createOrder(walletConnection: WalletConnection, request: UnsignedOrderRequest): Promise<CreateOrderResponse>;
    /**
     * Cancel an Order
     * @param walletConnection - the pair of L1/L2 signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the cancelled Order
     * @throws {@link index.IMXError}
     */
    cancelOrder(walletConnection: WalletConnection, request: GetSignableCancelOrderRequest): Promise<CancelOrderResponse>;
    /**
     * Get details of a Trade with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Trade
     * @throws {@link index.IMXError}
     */
    getTrade(request: TradesApiGetTradeRequest): Promise<Trade>;
    /**
     * Get a list of Trades
     * @param request - optional request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Trades
     * @throws {@link index.IMXError}
     */
    listTrades(request?: TradesApiListTradesRequest): Promise<ListTradesResponse>;
    /**
     * Create a Trade
     * @param walletConnection - the pair of L1/L2 signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Trade
     * @throws {@link index.IMXError}
     */
    createTrade(walletConnection: WalletConnection, request: GetSignableTradeRequest): Promise<CreateTradeResponse>;
    /**
     * Get details of a Token
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Token
     * @throws {@link index.IMXError}
     */
    getToken(request: TokensApiGetTokenRequest): Promise<TokenDetails>;
    /**
     * Get a list of Tokens
     * @param request - optional request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Tokens
     * @throws {@link index.IMXError}
     */
    listTokens(request?: TokensApiListTokensRequest): Promise<ListTokensResponse>;
    /**
     * Get details of a Transfer with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Transfer
     * @throws {@link index.IMXError}
     */
    getTransfer(request: TransfersApiGetTransferRequest): Promise<Transfer>;
    /**
     * Get a list of Transfers
     * @param request - optional request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Transfers
     * @throws {@link index.IMXError}
     */
    listTransfers(request?: TransfersApiListTransfersRequest): Promise<ListTransfersResponse>;
    /**
     * Create a new Transfer request
     * @param walletConnection - the pair of L1/L2 signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Transfer
     * @throws {@link index.IMXError}
     */
    transfer(walletConnection: WalletConnection, request: UnsignedTransferRequest): Promise<CreateTransferResponseV1>;
    /**
     * Create a batch of NFT transfer requests
     * @param walletConnection - the pair of L1/L2 signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the list of Transfer IDs
     * @throws {@link index.IMXError}
     */
    batchNftTransfer(walletConnection: WalletConnection, request: Array<NftTransferDetails>): Promise<CreateTransferResponse>;
    /**
     * Create a new Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transaction
     * @throws {@link index.IMXError}
     */
    createExchange(request: ExchangesApiCreateExchangeRequest): Promise<axios.AxiosResponse<ExchangeCreateExchangeAndURLResponse, any>>;
    /**
     * Get an Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the Exchange Transaction
     * @throws {@link index.IMXError}
     */
    getExchange(request: ExchangesApiGetExchangeRequest): Promise<axios.AxiosResponse<Exchange, any>>;
    /**
     * Get Exchange transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with Exchange Transactions
     * @throws {@link index.IMXError}
     */
    getExchanges(request: ExchangesApiGetExchangesRequest): Promise<axios.AxiosResponse<GetTransactionsResponse, any>>;
    /**
     * Create a new Transfer request
     * @param walletConnection - the pair of Eth/Stark signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transfer
     * @throws {@link index.IMXError}
     */
    exchangeTransfer(walletConnection: WalletConnection, request: UnsignedExchangeTransferRequest): Promise<CreateTransferResponseV1>;
    /**
     * Create a new nft primary transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created nft primary Transaction
     * @throws {@link index.IMXError}
     */
    createNftPrimary(request: NftCheckoutPrimaryApiCreateNftPrimaryRequest): Promise<axios.AxiosResponse<NftprimarytransactionCreateResponse, any>>;
    /**
     * Get nft primary supported currencies and their limits
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary Currencies
     * @throws {@link index.IMXError}
     */
    getCurrenciesNFTCheckoutPrimary(request: NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest): Promise<axios.AxiosResponse<CurrencyWithLimits, any>>;
    /**
     * Get nft primary transaction by transaction id
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransaction(request: NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest): Promise<axios.AxiosResponse<NftprimarytransactionGetResponse, any>>;
    /**
     * Get list of nft primary transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransactions(request: NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest): Promise<axios.AxiosResponse<NftprimarytransactionListTransactionsResponse, any>>;
}

export { APIError, AddMetadataSchemaToCollectionRequest, AggregateLimit, AnyToken, Asset, AssetProperties, AssetWithOrders, AssetsApi, AssetsApiAxiosParamCreator, AssetsApiFactory, AssetsApiFp, AssetsApiGetAssetRequest, AssetsApiListAssetsRequest, Balance, BalancesApi, BalancesApiAxiosParamCreator, BalancesApiFactory, BalancesApiFp, BalancesApiGetBalanceRequest, BalancesApiListBalancesRequest, CancelOrderRequest, CancelOrderResponse, Collection, CollectionDetails, CollectionFilter, CollectionsApi, CollectionsApiAxiosParamCreator, CollectionsApiCreateCollectionRequest, CollectionsApiFactory, CollectionsApiFp, CollectionsApiGetCollectionRequest, CollectionsApiListCollectionFiltersRequest, CollectionsApiListCollectionsRequest, CollectionsApiUpdateCollectionRequest, Config, Configuration, ConfigurationParameters, ContractCreateAPIRequest, ContractCreateResponse, exportContracts_d as Contracts, CreateCollectionRequest, CreateExchangeAndURLAPIRequest, CreateExchangeAndURLAPIRequestProviderEnum, CreateExchangeAndURLAPIRequestTypeEnum, CreateMetadataRefreshRequest, CreateMetadataRefreshResponse, CreateOrderRequest, CreateOrderResponse, CreateProjectRequest, CreateProjectResponse, CreateTradeRequestV1, CreateTradeResponse, CreateTransferRequest, CreateTransferRequestV1, CreateTransferResponse, CreateTransferResponseV1, CreateWithdrawalRequest, CreateWithdrawalResponse, CurrencyWithLimits, Deposit, DepositsApi, DepositsApiAxiosParamCreator, DepositsApiFactory, DepositsApiFp, DepositsApiGetDepositRequest, DepositsApiGetSignableDepositRequest, DepositsApiListDepositsRequest, ERC20Amount, ERC20Token, ERC721Token, ETHAmount, ETHToken, EncodeAssetRequest, EncodeAssetRequestToken, EncodeAssetRequestTokenTypeEnum, EncodeAssetResponse, EncodeAssetTokenData, EncodingApi, EncodingApiAxiosParamCreator, EncodingApiEncodeAssetRequest, EncodingApiFactory, EncodingApiFp, EthConfiguration, Exchange, ExchangeCreateExchangeAndURLResponse, ExchangeTokenAmount, ExchangesApi, ExchangesApiAxiosParamCreator, ExchangesApiCreateExchangeRequest, ExchangesApiCreateExchangeTransferRequest, ExchangesApiFactory, ExchangesApiFp, ExchangesApiGetExchangeRequest, ExchangesApiGetExchangeSignableTransferRequest, ExchangesApiGetExchangesRequest, Fee, FeeData, FeeEntry, FeeInfo, FeeToken, FeeTokenTypeEnum, GetMetadataRefreshErrorsResponse, GetMetadataRefreshResponse, GetMetadataRefreshResponseStatusEnum, GetMetadataRefreshes, GetProjectsResponse, GetSignableCancelOrderRequest, GetSignableCancelOrderResponse, GetSignableDepositRequest, GetSignableDepositResponse, GetSignableOrderRequest, GetSignableOrderResponse, GetSignableRegistrationOffchainResponse, GetSignableRegistrationRequest, GetSignableRegistrationResponse, GetSignableTradeRequest, GetSignableTradeResponse, GetSignableTransferRequest, GetSignableTransferRequestV1, GetSignableTransferResponse, GetSignableTransferResponseV1, GetSignableWithdrawalRequest, GetSignableWithdrawalResponse, GetTransactionsResponse, GetUsersApiResponse, IMXError, ImmutableX, ImmutableXConfiguration, LambdasAPIError, ListAssetsResponse, ListBalancesResponse, ListCollectionsResponse, ListDepositsResponse, ListMintsResponse, ListOrdersResponse, ListTokensResponse, ListTradesResponse, ListTransfersResponse, ListWithdrawalsResponse, MetadataApi, MetadataApiAddMetadataSchemaToCollectionRequest, MetadataApiAxiosParamCreator, MetadataApiFactory, MetadataApiFp, MetadataApiGetMetadataSchemaRequest, MetadataApiUpdateMetadataSchemaByNameRequest, MetadataRefreshErrors, MetadataRefreshExcludingSummary, MetadataRefreshExcludingSummaryStatusEnum, MetadataRefreshSummary, MetadataRefreshesApi, MetadataRefreshesApiAxiosParamCreator, MetadataRefreshesApiFactory, MetadataRefreshesApiFp, MetadataRefreshesApiGetAListOfMetadataRefreshesRequest, MetadataRefreshesApiGetMetadataRefreshErrorsRequest, MetadataRefreshesApiGetMetadataRefreshResultsRequest, MetadataRefreshesApiRequestAMetadataRefreshRequest, MetadataSchemaProperty, MetadataSchemaRequest, MetadataSchemaRequestTypeEnum, Mint, MintFee, MintRequest, MintResultDetails, MintTokenDataV2, MintTokensResponse, MintUser, MintableTokenDetails, MintsApi, MintsApiAxiosParamCreator, MintsApiFactory, MintsApiFp, MintsApiGetMintRequest, MintsApiGetMintableTokenDetailsByClientTokenIdRequest, MintsApiListMintsRequest, MintsApiMintTokensRequest, NftCheckoutPrimaryApi, NftCheckoutPrimaryApiAxiosParamCreator, NftCheckoutPrimaryApiCreateNftPrimaryRequest, NftCheckoutPrimaryApiFactory, NftCheckoutPrimaryApiFp, NftCheckoutPrimaryApiGetCurrenciesNFTCheckoutPrimaryRequest, NftCheckoutPrimaryApiGetNftPrimaryTransactionRequest, NftCheckoutPrimaryApiGetNftPrimaryTransactionsRequest, NftCheckoutPrimaryApiRegisterNftPrimarySalesContractRequest, NftTransferDetails, NftprimarytransactionCreateAPIRequest, NftprimarytransactionCreateResponse, NftprimarytransactionGetResponse, NftprimarytransactionListTransactionsResponse, NftprimarytransactionTransactionData, NftprimarytransactionWidgetParams, OptionalExchangeData, Order, OrderDetails, OrderFeeInfo, OrdersApi, OrdersApiAxiosParamCreator, OrdersApiCancelOrderRequest, OrdersApiCreateOrderRequest, OrdersApiFactory, OrdersApiFp, OrdersApiGetOrderRequest, OrdersApiGetSignableCancelOrderRequest, OrdersApiGetSignableOrderRequest, OrdersApiListOrdersRequest, Project, ProjectsApi, ProjectsApiAxiosParamCreator, ProjectsApiCreateProjectRequest, ProjectsApiFactory, ProjectsApiFp, ProjectsApiGetProjectRequest, ProjectsApiGetProjectsRequest, Range, RegisterUserRequest, RegisterUserResponse, SignableToken, SignableTransferDetails, SignableTransferResponseDetails, StarkSigner, SuccessResponse, Token, TokenAmount, TokenData, TokenDetails, TokensApi, TokensApiAxiosParamCreator, TokensApiFactory, TokensApiFp, TokensApiGetTokenRequest, TokensApiListTokensRequest, Trade, TradeSide, TradesApi, TradesApiAxiosParamCreator, TradesApiCreateTradeRequest, TradesApiFactory, TradesApiFp, TradesApiGetSignableTradeRequest, TradesApiGetTradeRequest, TradesApiListTradesRequest, Transfer, TransferRequest, TransfersApi, TransfersApiAxiosParamCreator, TransfersApiCreateTransferRequest, TransfersApiCreateTransferV1Request, TransfersApiFactory, TransfersApiFp, TransfersApiGetSignableTransferRequest, TransfersApiGetSignableTransferV1Request, TransfersApiGetTransferRequest, TransfersApiListTransfersRequest, UnsignedExchangeTransferRequest, UnsignedMintRequest, UnsignedOrderRequest, UnsignedTransferRequest, UpdateCollectionRequest, UsersApi, UsersApiAxiosParamCreator, UsersApiFactory, UsersApiFp, UsersApiGetSignableRegistrationOffchainRequest, UsersApiGetSignableRegistrationRequest, UsersApiGetUsersRequest, UsersApiRegisterUserRequest, WalletConnection, WidgetParams, Withdrawal, WithdrawalsApi, WithdrawalsApiAxiosParamCreator, WithdrawalsApiCreateWithdrawalRequest, WithdrawalsApiFactory, WithdrawalsApiFp, WithdrawalsApiGetSignableWithdrawalRequest, WithdrawalsApiGetWithdrawalRequest, WithdrawalsApiListWithdrawalsRequest, createStarkSigner, generateLegacyStarkPrivateKey, generateStarkPrivateKey };
